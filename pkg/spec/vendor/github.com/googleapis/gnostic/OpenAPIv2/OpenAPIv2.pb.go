// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: OpenAPIv2.proto

/*
	Package openapi_v2 is a generated protocol buffer package.

	It is generated from these files:
		OpenAPIv2.proto

	It has these top-level messages:
		AdditionalPropertiesItem
		Any
		ApiKeySecurity
		BasicAuthenticationSecurity
		BodyParameter
		Contact
		Default
		Definitions
		Document
		Examples
		ExternalDocs
		FileSchema
		FormDataParameterSubSchema
		Header
		HeaderParameterSubSchema
		Headers
		Info
		ItemsItem
		JsonReference
		License
		NamedAny
		NamedHeader
		NamedParameter
		NamedPathItem
		NamedResponse
		NamedResponseValue
		NamedSchema
		NamedSecurityDefinitionsItem
		NamedString
		NamedStringArray
		NonBodyParameter
		Oauth2AccessCodeSecurity
		Oauth2ApplicationSecurity
		Oauth2ImplicitSecurity
		Oauth2PasswordSecurity
		Oauth2Scopes
		Operation
		Parameter
		ParameterDefinitions
		ParametersItem
		PathItem
		PathParameterSubSchema
		Paths
		PrimitivesItems
		Properties
		QueryParameterSubSchema
		Response
		ResponseDefinitions
		ResponseValue
		Responses
		Schema
		SchemaItem
		SecurityDefinitions
		SecurityDefinitionsItem
		SecurityRequirement
		StringArray
		Tag
		TypeItem
		VendorExtension
		Xml
*/
package openapi_v2

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type AdditionalPropertiesItem struct {
	// Types that are valid to be assigned to Oneof:
	//	*AdditionalPropertiesItem_Schema
	//	*AdditionalPropertiesItem_Boolean
	Oneof isAdditionalPropertiesItem_Oneof `protobuf_oneof:"oneof"`
}

func (m *AdditionalPropertiesItem) Reset()         { *m = AdditionalPropertiesItem{} }
func (m *AdditionalPropertiesItem) String() string { return proto.CompactTextString(m) }
func (*AdditionalPropertiesItem) ProtoMessage()    {}
func (*AdditionalPropertiesItem) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenAPIv2, []int{0}
}

type isAdditionalPropertiesItem_Oneof interface {
	isAdditionalPropertiesItem_Oneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AdditionalPropertiesItem_Schema struct {
	Schema *Schema `protobuf:"bytes,1,opt,name=schema,oneof"`
}
type AdditionalPropertiesItem_Boolean struct {
	Boolean bool `protobuf:"varint,2,opt,name=boolean,proto3,oneof"`
}

func (*AdditionalPropertiesItem_Schema) isAdditionalPropertiesItem_Oneof()  {}
func (*AdditionalPropertiesItem_Boolean) isAdditionalPropertiesItem_Oneof() {}

func (m *AdditionalPropertiesItem) GetOneof() isAdditionalPropertiesItem_Oneof {
	if m != nil {
		return m.Oneof
	}
	return nil
}

func (m *AdditionalPropertiesItem) GetSchema() *Schema {
	if x, ok := m.GetOneof().(*AdditionalPropertiesItem_Schema); ok {
		return x.Schema
	}
	return nil
}

func (m *AdditionalPropertiesItem) GetBoolean() bool {
	if x, ok := m.GetOneof().(*AdditionalPropertiesItem_Boolean); ok {
		return x.Boolean
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AdditionalPropertiesItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AdditionalPropertiesItem_OneofMarshaler, _AdditionalPropertiesItem_OneofUnmarshaler, _AdditionalPropertiesItem_OneofSizer, []interface{}{
		(*AdditionalPropertiesItem_Schema)(nil),
		(*AdditionalPropertiesItem_Boolean)(nil),
	}
}

func _AdditionalPropertiesItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AdditionalPropertiesItem)
	// oneof
	switch x := m.Oneof.(type) {
	case *AdditionalPropertiesItem_Schema:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Schema); err != nil {
			return err
		}
	case *AdditionalPropertiesItem_Boolean:
		t := uint64(0)
		if x.Boolean {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("AdditionalPropertiesItem.Oneof has unexpected type %T", x)
	}
	return nil
}

func _AdditionalPropertiesItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AdditionalPropertiesItem)
	switch tag {
	case 1: // oneof.schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Schema)
		err := b.DecodeMessage(msg)
		m.Oneof = &AdditionalPropertiesItem_Schema{msg}
		return true, err
	case 2: // oneof.boolean
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Oneof = &AdditionalPropertiesItem_Boolean{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _AdditionalPropertiesItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AdditionalPropertiesItem)
	// oneof
	switch x := m.Oneof.(type) {
	case *AdditionalPropertiesItem_Schema:
		s := proto.Size(x.Schema)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdditionalPropertiesItem_Boolean:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Any struct {
	Value *google_protobuf.Any `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	Yaml  string               `protobuf:"bytes,2,opt,name=yaml,proto3" json:"yaml,omitempty"`
}

func (m *Any) Reset()                    { *m = Any{} }
func (m *Any) String() string            { return proto.CompactTextString(m) }
func (*Any) ProtoMessage()               {}
func (*Any) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{1} }

func (m *Any) GetValue() *google_protobuf.Any {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Any) GetYaml() string {
	if m != nil {
		return m.Yaml
	}
	return ""
}

type ApiKeySecurity struct {
	Type            string      `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Name            string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	In              string      `protobuf:"bytes,3,opt,name=in,proto3" json:"in,omitempty"`
	Description     string      `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	VendorExtension []*NamedAny `protobuf:"bytes,5,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *ApiKeySecurity) Reset()                    { *m = ApiKeySecurity{} }
func (m *ApiKeySecurity) String() string            { return proto.CompactTextString(m) }
func (*ApiKeySecurity) ProtoMessage()               {}
func (*ApiKeySecurity) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{2} }

func (m *ApiKeySecurity) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ApiKeySecurity) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ApiKeySecurity) GetIn() string {
	if m != nil {
		return m.In
	}
	return ""
}

func (m *ApiKeySecurity) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ApiKeySecurity) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type BasicAuthenticationSecurity struct {
	Type            string      `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Description     string      `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	VendorExtension []*NamedAny `protobuf:"bytes,3,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *BasicAuthenticationSecurity) Reset()         { *m = BasicAuthenticationSecurity{} }
func (m *BasicAuthenticationSecurity) String() string { return proto.CompactTextString(m) }
func (*BasicAuthenticationSecurity) ProtoMessage()    {}
func (*BasicAuthenticationSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenAPIv2, []int{3}
}

func (m *BasicAuthenticationSecurity) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *BasicAuthenticationSecurity) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BasicAuthenticationSecurity) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type BodyParameter struct {
	// A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// The name of the parameter.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Determines the location of the parameter.
	In string `protobuf:"bytes,3,opt,name=in,proto3" json:"in,omitempty"`
	// Determines whether or not this parameter is required or optional.
	Required        bool        `protobuf:"varint,4,opt,name=required,proto3" json:"required,omitempty"`
	Schema          *Schema     `protobuf:"bytes,5,opt,name=schema" json:"schema,omitempty"`
	VendorExtension []*NamedAny `protobuf:"bytes,6,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *BodyParameter) Reset()                    { *m = BodyParameter{} }
func (m *BodyParameter) String() string            { return proto.CompactTextString(m) }
func (*BodyParameter) ProtoMessage()               {}
func (*BodyParameter) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{4} }

func (m *BodyParameter) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BodyParameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BodyParameter) GetIn() string {
	if m != nil {
		return m.In
	}
	return ""
}

func (m *BodyParameter) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *BodyParameter) GetSchema() *Schema {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *BodyParameter) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

// Contact information for the owners of the API.
type Contact struct {
	// The identifying name of the contact person/organization.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The URL pointing to the contact information.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// The email address of the contact person/organization.
	Email           string      `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	VendorExtension []*NamedAny `protobuf:"bytes,4,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Contact) Reset()                    { *m = Contact{} }
func (m *Contact) String() string            { return proto.CompactTextString(m) }
func (*Contact) ProtoMessage()               {}
func (*Contact) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{5} }

func (m *Contact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Contact) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Contact) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *Contact) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type Default struct {
	AdditionalProperties []*NamedAny `protobuf:"bytes,1,rep,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
}

func (m *Default) Reset()                    { *m = Default{} }
func (m *Default) String() string            { return proto.CompactTextString(m) }
func (*Default) ProtoMessage()               {}
func (*Default) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{6} }

func (m *Default) GetAdditionalProperties() []*NamedAny {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

// One or more JSON objects describing the schemas being consumed and produced by the API.
type Definitions struct {
	AdditionalProperties []*NamedSchema `protobuf:"bytes,1,rep,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
}

func (m *Definitions) Reset()                    { *m = Definitions{} }
func (m *Definitions) String() string            { return proto.CompactTextString(m) }
func (*Definitions) ProtoMessage()               {}
func (*Definitions) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{7} }

func (m *Definitions) GetAdditionalProperties() []*NamedSchema {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

type Document struct {
	// The Swagger version of this document.
	Swagger string `protobuf:"bytes,1,opt,name=swagger,proto3" json:"swagger,omitempty"`
	Info    *Info  `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
	// The host (name or ip) of the API. Example: 'swagger.io'
	Host string `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
	// The base path to the API. Example: '/api'.
	BasePath string `protobuf:"bytes,4,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
	// The transfer protocol of the API.
	Schemes []string `protobuf:"bytes,5,rep,name=schemes" json:"schemes,omitempty"`
	// A list of MIME types accepted by the API.
	Consumes []string `protobuf:"bytes,6,rep,name=consumes" json:"consumes,omitempty"`
	// A list of MIME types the API can produce.
	Produces            []string               `protobuf:"bytes,7,rep,name=produces" json:"produces,omitempty"`
	Paths               *Paths                 `protobuf:"bytes,8,opt,name=paths" json:"paths,omitempty"`
	Definitions         *Definitions           `protobuf:"bytes,9,opt,name=definitions" json:"definitions,omitempty"`
	Parameters          *ParameterDefinitions  `protobuf:"bytes,10,opt,name=parameters" json:"parameters,omitempty"`
	Responses           *ResponseDefinitions   `protobuf:"bytes,11,opt,name=responses" json:"responses,omitempty"`
	Security            []*SecurityRequirement `protobuf:"bytes,12,rep,name=security" json:"security,omitempty"`
	SecurityDefinitions *SecurityDefinitions   `protobuf:"bytes,13,opt,name=security_definitions,json=securityDefinitions" json:"security_definitions,omitempty"`
	Tags                []*Tag                 `protobuf:"bytes,14,rep,name=tags" json:"tags,omitempty"`
	ExternalDocs        *ExternalDocs          `protobuf:"bytes,15,opt,name=external_docs,json=externalDocs" json:"external_docs,omitempty"`
	VendorExtension     []*NamedAny            `protobuf:"bytes,16,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Document) Reset()                    { *m = Document{} }
func (m *Document) String() string            { return proto.CompactTextString(m) }
func (*Document) ProtoMessage()               {}
func (*Document) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{8} }

func (m *Document) GetSwagger() string {
	if m != nil {
		return m.Swagger
	}
	return ""
}

func (m *Document) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Document) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Document) GetBasePath() string {
	if m != nil {
		return m.BasePath
	}
	return ""
}

func (m *Document) GetSchemes() []string {
	if m != nil {
		return m.Schemes
	}
	return nil
}

func (m *Document) GetConsumes() []string {
	if m != nil {
		return m.Consumes
	}
	return nil
}

func (m *Document) GetProduces() []string {
	if m != nil {
		return m.Produces
	}
	return nil
}

func (m *Document) GetPaths() *Paths {
	if m != nil {
		return m.Paths
	}
	return nil
}

func (m *Document) GetDefinitions() *Definitions {
	if m != nil {
		return m.Definitions
	}
	return nil
}

func (m *Document) GetParameters() *ParameterDefinitions {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Document) GetResponses() *ResponseDefinitions {
	if m != nil {
		return m.Responses
	}
	return nil
}

func (m *Document) GetSecurity() []*SecurityRequirement {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *Document) GetSecurityDefinitions() *SecurityDefinitions {
	if m != nil {
		return m.SecurityDefinitions
	}
	return nil
}

func (m *Document) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Document) GetExternalDocs() *ExternalDocs {
	if m != nil {
		return m.ExternalDocs
	}
	return nil
}

func (m *Document) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type Examples struct {
	AdditionalProperties []*NamedAny `protobuf:"bytes,1,rep,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
}

func (m *Examples) Reset()                    { *m = Examples{} }
func (m *Examples) String() string            { return proto.CompactTextString(m) }
func (*Examples) ProtoMessage()               {}
func (*Examples) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{9} }

func (m *Examples) GetAdditionalProperties() []*NamedAny {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

// information about external documentation
type ExternalDocs struct {
	Description     string      `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Url             string      `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	VendorExtension []*NamedAny `protobuf:"bytes,3,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *ExternalDocs) Reset()                    { *m = ExternalDocs{} }
func (m *ExternalDocs) String() string            { return proto.CompactTextString(m) }
func (*ExternalDocs) ProtoMessage()               {}
func (*ExternalDocs) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{10} }

func (m *ExternalDocs) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ExternalDocs) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ExternalDocs) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

// A deterministic version of a JSON Schema object.
type FileSchema struct {
	Format          string        `protobuf:"bytes,1,opt,name=format,proto3" json:"format,omitempty"`
	Title           string        `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Description     string        `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Default         *Any          `protobuf:"bytes,4,opt,name=default" json:"default,omitempty"`
	Required        []string      `protobuf:"bytes,5,rep,name=required" json:"required,omitempty"`
	Type            string        `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	ReadOnly        bool          `protobuf:"varint,7,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	ExternalDocs    *ExternalDocs `protobuf:"bytes,8,opt,name=external_docs,json=externalDocs" json:"external_docs,omitempty"`
	Example         *Any          `protobuf:"bytes,9,opt,name=example" json:"example,omitempty"`
	VendorExtension []*NamedAny   `protobuf:"bytes,10,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *FileSchema) Reset()                    { *m = FileSchema{} }
func (m *FileSchema) String() string            { return proto.CompactTextString(m) }
func (*FileSchema) ProtoMessage()               {}
func (*FileSchema) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{11} }

func (m *FileSchema) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *FileSchema) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *FileSchema) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FileSchema) GetDefault() *Any {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *FileSchema) GetRequired() []string {
	if m != nil {
		return m.Required
	}
	return nil
}

func (m *FileSchema) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *FileSchema) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *FileSchema) GetExternalDocs() *ExternalDocs {
	if m != nil {
		return m.ExternalDocs
	}
	return nil
}

func (m *FileSchema) GetExample() *Any {
	if m != nil {
		return m.Example
	}
	return nil
}

func (m *FileSchema) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type FormDataParameterSubSchema struct {
	// Determines whether or not this parameter is required or optional.
	Required bool `protobuf:"varint,1,opt,name=required,proto3" json:"required,omitempty"`
	// Determines the location of the parameter.
	In string `protobuf:"bytes,2,opt,name=in,proto3" json:"in,omitempty"`
	// A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// The name of the parameter.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// allows sending a parameter by name only or with an empty value.
	AllowEmptyValue  bool             `protobuf:"varint,5,opt,name=allow_empty_value,json=allowEmptyValue,proto3" json:"allow_empty_value,omitempty"`
	Type             string           `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	Format           string           `protobuf:"bytes,7,opt,name=format,proto3" json:"format,omitempty"`
	Items            *PrimitivesItems `protobuf:"bytes,8,opt,name=items" json:"items,omitempty"`
	CollectionFormat string           `protobuf:"bytes,9,opt,name=collection_format,json=collectionFormat,proto3" json:"collection_format,omitempty"`
	Default          *Any             `protobuf:"bytes,10,opt,name=default" json:"default,omitempty"`
	Maximum          float64          `protobuf:"fixed64,11,opt,name=maximum,proto3" json:"maximum,omitempty"`
	ExclusiveMaximum bool             `protobuf:"varint,12,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
	Minimum          float64          `protobuf:"fixed64,13,opt,name=minimum,proto3" json:"minimum,omitempty"`
	ExclusiveMinimum bool             `protobuf:"varint,14,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
	MaxLength        int64            `protobuf:"varint,15,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	MinLength        int64            `protobuf:"varint,16,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
	Pattern          string           `protobuf:"bytes,17,opt,name=pattern,proto3" json:"pattern,omitempty"`
	MaxItems         int64            `protobuf:"varint,18,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
	MinItems         int64            `protobuf:"varint,19,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
	UniqueItems      bool             `protobuf:"varint,20,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
	Enum             []*Any           `protobuf:"bytes,21,rep,name=enum" json:"enum,omitempty"`
	MultipleOf       float64          `protobuf:"fixed64,22,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
	VendorExtension  []*NamedAny      `protobuf:"bytes,23,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *FormDataParameterSubSchema) Reset()         { *m = FormDataParameterSubSchema{} }
func (m *FormDataParameterSubSchema) String() string { return proto.CompactTextString(m) }
func (*FormDataParameterSubSchema) ProtoMessage()    {}
func (*FormDataParameterSubSchema) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenAPIv2, []int{12}
}

func (m *FormDataParameterSubSchema) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *FormDataParameterSubSchema) GetIn() string {
	if m != nil {
		return m.In
	}
	return ""
}

func (m *FormDataParameterSubSchema) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FormDataParameterSubSchema) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FormDataParameterSubSchema) GetAllowEmptyValue() bool {
	if m != nil {
		return m.AllowEmptyValue
	}
	return false
}

func (m *FormDataParameterSubSchema) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *FormDataParameterSubSchema) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *FormDataParameterSubSchema) GetItems() *PrimitivesItems {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *FormDataParameterSubSchema) GetCollectionFormat() string {
	if m != nil {
		return m.CollectionFormat
	}
	return ""
}

func (m *FormDataParameterSubSchema) GetDefault() *Any {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *FormDataParameterSubSchema) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *FormDataParameterSubSchema) GetExclusiveMaximum() bool {
	if m != nil {
		return m.ExclusiveMaximum
	}
	return false
}

func (m *FormDataParameterSubSchema) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *FormDataParameterSubSchema) GetExclusiveMinimum() bool {
	if m != nil {
		return m.ExclusiveMinimum
	}
	return false
}

func (m *FormDataParameterSubSchema) GetMaxLength() int64 {
	if m != nil {
		return m.MaxLength
	}
	return 0
}

func (m *FormDataParameterSubSchema) GetMinLength() int64 {
	if m != nil {
		return m.MinLength
	}
	return 0
}

func (m *FormDataParameterSubSchema) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *FormDataParameterSubSchema) GetMaxItems() int64 {
	if m != nil {
		return m.MaxItems
	}
	return 0
}

func (m *FormDataParameterSubSchema) GetMinItems() int64 {
	if m != nil {
		return m.MinItems
	}
	return 0
}

func (m *FormDataParameterSubSchema) GetUniqueItems() bool {
	if m != nil {
		return m.UniqueItems
	}
	return false
}

func (m *FormDataParameterSubSchema) GetEnum() []*Any {
	if m != nil {
		return m.Enum
	}
	return nil
}

func (m *FormDataParameterSubSchema) GetMultipleOf() float64 {
	if m != nil {
		return m.MultipleOf
	}
	return 0
}

func (m *FormDataParameterSubSchema) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type Header struct {
	Type             string           `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Format           string           `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	Items            *PrimitivesItems `protobuf:"bytes,3,opt,name=items" json:"items,omitempty"`
	CollectionFormat string           `protobuf:"bytes,4,opt,name=collection_format,json=collectionFormat,proto3" json:"collection_format,omitempty"`
	Default          *Any             `protobuf:"bytes,5,opt,name=default" json:"default,omitempty"`
	Maximum          float64          `protobuf:"fixed64,6,opt,name=maximum,proto3" json:"maximum,omitempty"`
	ExclusiveMaximum bool             `protobuf:"varint,7,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
	Minimum          float64          `protobuf:"fixed64,8,opt,name=minimum,proto3" json:"minimum,omitempty"`
	ExclusiveMinimum bool             `protobuf:"varint,9,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
	MaxLength        int64            `protobuf:"varint,10,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	MinLength        int64            `protobuf:"varint,11,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
	Pattern          string           `protobuf:"bytes,12,opt,name=pattern,proto3" json:"pattern,omitempty"`
	MaxItems         int64            `protobuf:"varint,13,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
	MinItems         int64            `protobuf:"varint,14,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
	UniqueItems      bool             `protobuf:"varint,15,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
	Enum             []*Any           `protobuf:"bytes,16,rep,name=enum" json:"enum,omitempty"`
	MultipleOf       float64          `protobuf:"fixed64,17,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
	Description      string           `protobuf:"bytes,18,opt,name=description,proto3" json:"description,omitempty"`
	VendorExtension  []*NamedAny      `protobuf:"bytes,19,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Header) Reset()                    { *m = Header{} }
func (m *Header) String() string            { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()               {}
func (*Header) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{13} }

func (m *Header) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Header) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *Header) GetItems() *PrimitivesItems {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Header) GetCollectionFormat() string {
	if m != nil {
		return m.CollectionFormat
	}
	return ""
}

func (m *Header) GetDefault() *Any {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *Header) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *Header) GetExclusiveMaximum() bool {
	if m != nil {
		return m.ExclusiveMaximum
	}
	return false
}

func (m *Header) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *Header) GetExclusiveMinimum() bool {
	if m != nil {
		return m.ExclusiveMinimum
	}
	return false
}

func (m *Header) GetMaxLength() int64 {
	if m != nil {
		return m.MaxLength
	}
	return 0
}

func (m *Header) GetMinLength() int64 {
	if m != nil {
		return m.MinLength
	}
	return 0
}

func (m *Header) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *Header) GetMaxItems() int64 {
	if m != nil {
		return m.MaxItems
	}
	return 0
}

func (m *Header) GetMinItems() int64 {
	if m != nil {
		return m.MinItems
	}
	return 0
}

func (m *Header) GetUniqueItems() bool {
	if m != nil {
		return m.UniqueItems
	}
	return false
}

func (m *Header) GetEnum() []*Any {
	if m != nil {
		return m.Enum
	}
	return nil
}

func (m *Header) GetMultipleOf() float64 {
	if m != nil {
		return m.MultipleOf
	}
	return 0
}

func (m *Header) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Header) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type HeaderParameterSubSchema struct {
	// Determines whether or not this parameter is required or optional.
	Required bool `protobuf:"varint,1,opt,name=required,proto3" json:"required,omitempty"`
	// Determines the location of the parameter.
	In string `protobuf:"bytes,2,opt,name=in,proto3" json:"in,omitempty"`
	// A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// The name of the parameter.
	Name             string           `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Type             string           `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty"`
	Format           string           `protobuf:"bytes,6,opt,name=format,proto3" json:"format,omitempty"`
	Items            *PrimitivesItems `protobuf:"bytes,7,opt,name=items" json:"items,omitempty"`
	CollectionFormat string           `protobuf:"bytes,8,opt,name=collection_format,json=collectionFormat,proto3" json:"collection_format,omitempty"`
	Default          *Any             `protobuf:"bytes,9,opt,name=default" json:"default,omitempty"`
	Maximum          float64          `protobuf:"fixed64,10,opt,name=maximum,proto3" json:"maximum,omitempty"`
	ExclusiveMaximum bool             `protobuf:"varint,11,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
	Minimum          float64          `protobuf:"fixed64,12,opt,name=minimum,proto3" json:"minimum,omitempty"`
	ExclusiveMinimum bool             `protobuf:"varint,13,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
	MaxLength        int64            `protobuf:"varint,14,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	MinLength        int64            `protobuf:"varint,15,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
	Pattern          string           `protobuf:"bytes,16,opt,name=pattern,proto3" json:"pattern,omitempty"`
	MaxItems         int64            `protobuf:"varint,17,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
	MinItems         int64            `protobuf:"varint,18,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
	UniqueItems      bool             `protobuf:"varint,19,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
	Enum             []*Any           `protobuf:"bytes,20,rep,name=enum" json:"enum,omitempty"`
	MultipleOf       float64          `protobuf:"fixed64,21,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
	VendorExtension  []*NamedAny      `protobuf:"bytes,22,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *HeaderParameterSubSchema) Reset()         { *m = HeaderParameterSubSchema{} }
func (m *HeaderParameterSubSchema) String() string { return proto.CompactTextString(m) }
func (*HeaderParameterSubSchema) ProtoMessage()    {}
func (*HeaderParameterSubSchema) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenAPIv2, []int{14}
}

func (m *HeaderParameterSubSchema) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *HeaderParameterSubSchema) GetIn() string {
	if m != nil {
		return m.In
	}
	return ""
}

func (m *HeaderParameterSubSchema) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *HeaderParameterSubSchema) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderParameterSubSchema) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *HeaderParameterSubSchema) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *HeaderParameterSubSchema) GetItems() *PrimitivesItems {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *HeaderParameterSubSchema) GetCollectionFormat() string {
	if m != nil {
		return m.CollectionFormat
	}
	return ""
}

func (m *HeaderParameterSubSchema) GetDefault() *Any {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *HeaderParameterSubSchema) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *HeaderParameterSubSchema) GetExclusiveMaximum() bool {
	if m != nil {
		return m.ExclusiveMaximum
	}
	return false
}

func (m *HeaderParameterSubSchema) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *HeaderParameterSubSchema) GetExclusiveMinimum() bool {
	if m != nil {
		return m.ExclusiveMinimum
	}
	return false
}

func (m *HeaderParameterSubSchema) GetMaxLength() int64 {
	if m != nil {
		return m.MaxLength
	}
	return 0
}

func (m *HeaderParameterSubSchema) GetMinLength() int64 {
	if m != nil {
		return m.MinLength
	}
	return 0
}

func (m *HeaderParameterSubSchema) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *HeaderParameterSubSchema) GetMaxItems() int64 {
	if m != nil {
		return m.MaxItems
	}
	return 0
}

func (m *HeaderParameterSubSchema) GetMinItems() int64 {
	if m != nil {
		return m.MinItems
	}
	return 0
}

func (m *HeaderParameterSubSchema) GetUniqueItems() bool {
	if m != nil {
		return m.UniqueItems
	}
	return false
}

func (m *HeaderParameterSubSchema) GetEnum() []*Any {
	if m != nil {
		return m.Enum
	}
	return nil
}

func (m *HeaderParameterSubSchema) GetMultipleOf() float64 {
	if m != nil {
		return m.MultipleOf
	}
	return 0
}

func (m *HeaderParameterSubSchema) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type Headers struct {
	AdditionalProperties []*NamedHeader `protobuf:"bytes,1,rep,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
}

func (m *Headers) Reset()                    { *m = Headers{} }
func (m *Headers) String() string            { return proto.CompactTextString(m) }
func (*Headers) ProtoMessage()               {}
func (*Headers) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{15} }

func (m *Headers) GetAdditionalProperties() []*NamedHeader {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

// General information about the API.
type Info struct {
	// A unique and precise title of the API.
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// A semantic version number of the API.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// The terms of service for the API.
	TermsOfService  string      `protobuf:"bytes,4,opt,name=terms_of_service,json=termsOfService,proto3" json:"terms_of_service,omitempty"`
	Contact         *Contact    `protobuf:"bytes,5,opt,name=contact" json:"contact,omitempty"`
	License         *License    `protobuf:"bytes,6,opt,name=license" json:"license,omitempty"`
	VendorExtension []*NamedAny `protobuf:"bytes,7,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Info) Reset()                    { *m = Info{} }
func (m *Info) String() string            { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()               {}
func (*Info) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{16} }

func (m *Info) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Info) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Info) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Info) GetTermsOfService() string {
	if m != nil {
		return m.TermsOfService
	}
	return ""
}

func (m *Info) GetContact() *Contact {
	if m != nil {
		return m.Contact
	}
	return nil
}

func (m *Info) GetLicense() *License {
	if m != nil {
		return m.License
	}
	return nil
}

func (m *Info) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type ItemsItem struct {
	Schema []*Schema `protobuf:"bytes,1,rep,name=schema" json:"schema,omitempty"`
}

func (m *ItemsItem) Reset()                    { *m = ItemsItem{} }
func (m *ItemsItem) String() string            { return proto.CompactTextString(m) }
func (*ItemsItem) ProtoMessage()               {}
func (*ItemsItem) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{17} }

func (m *ItemsItem) GetSchema() []*Schema {
	if m != nil {
		return m.Schema
	}
	return nil
}

type JsonReference struct {
	XRef        string `protobuf:"bytes,1,opt,name=_ref,json=Ref,proto3" json:"_ref,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *JsonReference) Reset()                    { *m = JsonReference{} }
func (m *JsonReference) String() string            { return proto.CompactTextString(m) }
func (*JsonReference) ProtoMessage()               {}
func (*JsonReference) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{18} }

func (m *JsonReference) GetXRef() string {
	if m != nil {
		return m.XRef
	}
	return ""
}

func (m *JsonReference) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type License struct {
	// The name of the license type. It's encouraged to use an OSI compatible license.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The URL pointing to the license.
	Url             string      `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	VendorExtension []*NamedAny `protobuf:"bytes,3,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *License) Reset()                    { *m = License{} }
func (m *License) String() string            { return proto.CompactTextString(m) }
func (*License) ProtoMessage()               {}
func (*License) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{19} }

func (m *License) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *License) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *License) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

// Automatically-generated message used to represent maps of Any as ordered (name,value) pairs.
type NamedAny struct {
	// Map key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Mapped value
	Value *Any `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *NamedAny) Reset()                    { *m = NamedAny{} }
func (m *NamedAny) String() string            { return proto.CompactTextString(m) }
func (*NamedAny) ProtoMessage()               {}
func (*NamedAny) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{20} }

func (m *NamedAny) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamedAny) GetValue() *Any {
	if m != nil {
		return m.Value
	}
	return nil
}

// Automatically-generated message used to represent maps of Header as ordered (name,value) pairs.
type NamedHeader struct {
	// Map key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Mapped value
	Value *Header `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *NamedHeader) Reset()                    { *m = NamedHeader{} }
func (m *NamedHeader) String() string            { return proto.CompactTextString(m) }
func (*NamedHeader) ProtoMessage()               {}
func (*NamedHeader) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{21} }

func (m *NamedHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamedHeader) GetValue() *Header {
	if m != nil {
		return m.Value
	}
	return nil
}

// Automatically-generated message used to represent maps of Parameter as ordered (name,value) pairs.
type NamedParameter struct {
	// Map key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Mapped value
	Value *Parameter `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *NamedParameter) Reset()                    { *m = NamedParameter{} }
func (m *NamedParameter) String() string            { return proto.CompactTextString(m) }
func (*NamedParameter) ProtoMessage()               {}
func (*NamedParameter) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{22} }

func (m *NamedParameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamedParameter) GetValue() *Parameter {
	if m != nil {
		return m.Value
	}
	return nil
}

// Automatically-generated message used to represent maps of PathItem as ordered (name,value) pairs.
type NamedPathItem struct {
	// Map key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Mapped value
	Value *PathItem `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *NamedPathItem) Reset()                    { *m = NamedPathItem{} }
func (m *NamedPathItem) String() string            { return proto.CompactTextString(m) }
func (*NamedPathItem) ProtoMessage()               {}
func (*NamedPathItem) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{23} }

func (m *NamedPathItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamedPathItem) GetValue() *PathItem {
	if m != nil {
		return m.Value
	}
	return nil
}

// Automatically-generated message used to represent maps of Response as ordered (name,value) pairs.
type NamedResponse struct {
	// Map key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Mapped value
	Value *Response `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *NamedResponse) Reset()                    { *m = NamedResponse{} }
func (m *NamedResponse) String() string            { return proto.CompactTextString(m) }
func (*NamedResponse) ProtoMessage()               {}
func (*NamedResponse) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{24} }

func (m *NamedResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamedResponse) GetValue() *Response {
	if m != nil {
		return m.Value
	}
	return nil
}

// Automatically-generated message used to represent maps of ResponseValue as ordered (name,value) pairs.
type NamedResponseValue struct {
	// Map key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Mapped value
	Value *ResponseValue `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *NamedResponseValue) Reset()                    { *m = NamedResponseValue{} }
func (m *NamedResponseValue) String() string            { return proto.CompactTextString(m) }
func (*NamedResponseValue) ProtoMessage()               {}
func (*NamedResponseValue) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{25} }

func (m *NamedResponseValue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamedResponseValue) GetValue() *ResponseValue {
	if m != nil {
		return m.Value
	}
	return nil
}

// Automatically-generated message used to represent maps of Schema as ordered (name,value) pairs.
type NamedSchema struct {
	// Map key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Mapped value
	Value *Schema `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *NamedSchema) Reset()                    { *m = NamedSchema{} }
func (m *NamedSchema) String() string            { return proto.CompactTextString(m) }
func (*NamedSchema) ProtoMessage()               {}
func (*NamedSchema) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{26} }

func (m *NamedSchema) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamedSchema) GetValue() *Schema {
	if m != nil {
		return m.Value
	}
	return nil
}

// Automatically-generated message used to represent maps of SecurityDefinitionsItem as ordered (name,value) pairs.
type NamedSecurityDefinitionsItem struct {
	// Map key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Mapped value
	Value *SecurityDefinitionsItem `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *NamedSecurityDefinitionsItem) Reset()         { *m = NamedSecurityDefinitionsItem{} }
func (m *NamedSecurityDefinitionsItem) String() string { return proto.CompactTextString(m) }
func (*NamedSecurityDefinitionsItem) ProtoMessage()    {}
func (*NamedSecurityDefinitionsItem) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenAPIv2, []int{27}
}

func (m *NamedSecurityDefinitionsItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamedSecurityDefinitionsItem) GetValue() *SecurityDefinitionsItem {
	if m != nil {
		return m.Value
	}
	return nil
}

// Automatically-generated message used to represent maps of string as ordered (name,value) pairs.
type NamedString struct {
	// Map key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Mapped value
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *NamedString) Reset()                    { *m = NamedString{} }
func (m *NamedString) String() string            { return proto.CompactTextString(m) }
func (*NamedString) ProtoMessage()               {}
func (*NamedString) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{28} }

func (m *NamedString) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamedString) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Automatically-generated message used to represent maps of StringArray as ordered (name,value) pairs.
type NamedStringArray struct {
	// Map key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Mapped value
	Value *StringArray `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *NamedStringArray) Reset()                    { *m = NamedStringArray{} }
func (m *NamedStringArray) String() string            { return proto.CompactTextString(m) }
func (*NamedStringArray) ProtoMessage()               {}
func (*NamedStringArray) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{29} }

func (m *NamedStringArray) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamedStringArray) GetValue() *StringArray {
	if m != nil {
		return m.Value
	}
	return nil
}

type NonBodyParameter struct {
	// Types that are valid to be assigned to Oneof:
	//	*NonBodyParameter_HeaderParameterSubSchema
	//	*NonBodyParameter_FormDataParameterSubSchema
	//	*NonBodyParameter_QueryParameterSubSchema
	//	*NonBodyParameter_PathParameterSubSchema
	Oneof isNonBodyParameter_Oneof `protobuf_oneof:"oneof"`
}

func (m *NonBodyParameter) Reset()                    { *m = NonBodyParameter{} }
func (m *NonBodyParameter) String() string            { return proto.CompactTextString(m) }
func (*NonBodyParameter) ProtoMessage()               {}
func (*NonBodyParameter) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{30} }

type isNonBodyParameter_Oneof interface {
	isNonBodyParameter_Oneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NonBodyParameter_HeaderParameterSubSchema struct {
	HeaderParameterSubSchema *HeaderParameterSubSchema `protobuf:"bytes,1,opt,name=header_parameter_sub_schema,json=headerParameterSubSchema,oneof"`
}
type NonBodyParameter_FormDataParameterSubSchema struct {
	FormDataParameterSubSchema *FormDataParameterSubSchema `protobuf:"bytes,2,opt,name=form_data_parameter_sub_schema,json=formDataParameterSubSchema,oneof"`
}
type NonBodyParameter_QueryParameterSubSchema struct {
	QueryParameterSubSchema *QueryParameterSubSchema `protobuf:"bytes,3,opt,name=query_parameter_sub_schema,json=queryParameterSubSchema,oneof"`
}
type NonBodyParameter_PathParameterSubSchema struct {
	PathParameterSubSchema *PathParameterSubSchema `protobuf:"bytes,4,opt,name=path_parameter_sub_schema,json=pathParameterSubSchema,oneof"`
}

func (*NonBodyParameter_HeaderParameterSubSchema) isNonBodyParameter_Oneof()   {}
func (*NonBodyParameter_FormDataParameterSubSchema) isNonBodyParameter_Oneof() {}
func (*NonBodyParameter_QueryParameterSubSchema) isNonBodyParameter_Oneof()    {}
func (*NonBodyParameter_PathParameterSubSchema) isNonBodyParameter_Oneof()     {}

func (m *NonBodyParameter) GetOneof() isNonBodyParameter_Oneof {
	if m != nil {
		return m.Oneof
	}
	return nil
}

func (m *NonBodyParameter) GetHeaderParameterSubSchema() *HeaderParameterSubSchema {
	if x, ok := m.GetOneof().(*NonBodyParameter_HeaderParameterSubSchema); ok {
		return x.HeaderParameterSubSchema
	}
	return nil
}

func (m *NonBodyParameter) GetFormDataParameterSubSchema() *FormDataParameterSubSchema {
	if x, ok := m.GetOneof().(*NonBodyParameter_FormDataParameterSubSchema); ok {
		return x.FormDataParameterSubSchema
	}
	return nil
}

func (m *NonBodyParameter) GetQueryParameterSubSchema() *QueryParameterSubSchema {
	if x, ok := m.GetOneof().(*NonBodyParameter_QueryParameterSubSchema); ok {
		return x.QueryParameterSubSchema
	}
	return nil
}

func (m *NonBodyParameter) GetPathParameterSubSchema() *PathParameterSubSchema {
	if x, ok := m.GetOneof().(*NonBodyParameter_PathParameterSubSchema); ok {
		return x.PathParameterSubSchema
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NonBodyParameter) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NonBodyParameter_OneofMarshaler, _NonBodyParameter_OneofUnmarshaler, _NonBodyParameter_OneofSizer, []interface{}{
		(*NonBodyParameter_HeaderParameterSubSchema)(nil),
		(*NonBodyParameter_FormDataParameterSubSchema)(nil),
		(*NonBodyParameter_QueryParameterSubSchema)(nil),
		(*NonBodyParameter_PathParameterSubSchema)(nil),
	}
}

func _NonBodyParameter_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NonBodyParameter)
	// oneof
	switch x := m.Oneof.(type) {
	case *NonBodyParameter_HeaderParameterSubSchema:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HeaderParameterSubSchema); err != nil {
			return err
		}
	case *NonBodyParameter_FormDataParameterSubSchema:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FormDataParameterSubSchema); err != nil {
			return err
		}
	case *NonBodyParameter_QueryParameterSubSchema:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.QueryParameterSubSchema); err != nil {
			return err
		}
	case *NonBodyParameter_PathParameterSubSchema:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PathParameterSubSchema); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NonBodyParameter.Oneof has unexpected type %T", x)
	}
	return nil
}

func _NonBodyParameter_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NonBodyParameter)
	switch tag {
	case 1: // oneof.header_parameter_sub_schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HeaderParameterSubSchema)
		err := b.DecodeMessage(msg)
		m.Oneof = &NonBodyParameter_HeaderParameterSubSchema{msg}
		return true, err
	case 2: // oneof.form_data_parameter_sub_schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FormDataParameterSubSchema)
		err := b.DecodeMessage(msg)
		m.Oneof = &NonBodyParameter_FormDataParameterSubSchema{msg}
		return true, err
	case 3: // oneof.query_parameter_sub_schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QueryParameterSubSchema)
		err := b.DecodeMessage(msg)
		m.Oneof = &NonBodyParameter_QueryParameterSubSchema{msg}
		return true, err
	case 4: // oneof.path_parameter_sub_schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PathParameterSubSchema)
		err := b.DecodeMessage(msg)
		m.Oneof = &NonBodyParameter_PathParameterSubSchema{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NonBodyParameter_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NonBodyParameter)
	// oneof
	switch x := m.Oneof.(type) {
	case *NonBodyParameter_HeaderParameterSubSchema:
		s := proto.Size(x.HeaderParameterSubSchema)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NonBodyParameter_FormDataParameterSubSchema:
		s := proto.Size(x.FormDataParameterSubSchema)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NonBodyParameter_QueryParameterSubSchema:
		s := proto.Size(x.QueryParameterSubSchema)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NonBodyParameter_PathParameterSubSchema:
		s := proto.Size(x.PathParameterSubSchema)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Oauth2AccessCodeSecurity struct {
	Type             string        `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Flow             string        `protobuf:"bytes,2,opt,name=flow,proto3" json:"flow,omitempty"`
	Scopes           *Oauth2Scopes `protobuf:"bytes,3,opt,name=scopes" json:"scopes,omitempty"`
	AuthorizationUrl string        `protobuf:"bytes,4,opt,name=authorization_url,json=authorizationUrl,proto3" json:"authorization_url,omitempty"`
	TokenUrl         string        `protobuf:"bytes,5,opt,name=token_url,json=tokenUrl,proto3" json:"token_url,omitempty"`
	Description      string        `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	VendorExtension  []*NamedAny   `protobuf:"bytes,7,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Oauth2AccessCodeSecurity) Reset()         { *m = Oauth2AccessCodeSecurity{} }
func (m *Oauth2AccessCodeSecurity) String() string { return proto.CompactTextString(m) }
func (*Oauth2AccessCodeSecurity) ProtoMessage()    {}
func (*Oauth2AccessCodeSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenAPIv2, []int{31}
}

func (m *Oauth2AccessCodeSecurity) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Oauth2AccessCodeSecurity) GetFlow() string {
	if m != nil {
		return m.Flow
	}
	return ""
}

func (m *Oauth2AccessCodeSecurity) GetScopes() *Oauth2Scopes {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *Oauth2AccessCodeSecurity) GetAuthorizationUrl() string {
	if m != nil {
		return m.AuthorizationUrl
	}
	return ""
}

func (m *Oauth2AccessCodeSecurity) GetTokenUrl() string {
	if m != nil {
		return m.TokenUrl
	}
	return ""
}

func (m *Oauth2AccessCodeSecurity) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Oauth2AccessCodeSecurity) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type Oauth2ApplicationSecurity struct {
	Type            string        `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Flow            string        `protobuf:"bytes,2,opt,name=flow,proto3" json:"flow,omitempty"`
	Scopes          *Oauth2Scopes `protobuf:"bytes,3,opt,name=scopes" json:"scopes,omitempty"`
	TokenUrl        string        `protobuf:"bytes,4,opt,name=token_url,json=tokenUrl,proto3" json:"token_url,omitempty"`
	Description     string        `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	VendorExtension []*NamedAny   `protobuf:"bytes,6,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Oauth2ApplicationSecurity) Reset()         { *m = Oauth2ApplicationSecurity{} }
func (m *Oauth2ApplicationSecurity) String() string { return proto.CompactTextString(m) }
func (*Oauth2ApplicationSecurity) ProtoMessage()    {}
func (*Oauth2ApplicationSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenAPIv2, []int{32}
}

func (m *Oauth2ApplicationSecurity) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Oauth2ApplicationSecurity) GetFlow() string {
	if m != nil {
		return m.Flow
	}
	return ""
}

func (m *Oauth2ApplicationSecurity) GetScopes() *Oauth2Scopes {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *Oauth2ApplicationSecurity) GetTokenUrl() string {
	if m != nil {
		return m.TokenUrl
	}
	return ""
}

func (m *Oauth2ApplicationSecurity) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Oauth2ApplicationSecurity) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type Oauth2ImplicitSecurity struct {
	Type             string        `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Flow             string        `protobuf:"bytes,2,opt,name=flow,proto3" json:"flow,omitempty"`
	Scopes           *Oauth2Scopes `protobuf:"bytes,3,opt,name=scopes" json:"scopes,omitempty"`
	AuthorizationUrl string        `protobuf:"bytes,4,opt,name=authorization_url,json=authorizationUrl,proto3" json:"authorization_url,omitempty"`
	Description      string        `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	VendorExtension  []*NamedAny   `protobuf:"bytes,6,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Oauth2ImplicitSecurity) Reset()                    { *m = Oauth2ImplicitSecurity{} }
func (m *Oauth2ImplicitSecurity) String() string            { return proto.CompactTextString(m) }
func (*Oauth2ImplicitSecurity) ProtoMessage()               {}
func (*Oauth2ImplicitSecurity) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{33} }

func (m *Oauth2ImplicitSecurity) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Oauth2ImplicitSecurity) GetFlow() string {
	if m != nil {
		return m.Flow
	}
	return ""
}

func (m *Oauth2ImplicitSecurity) GetScopes() *Oauth2Scopes {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *Oauth2ImplicitSecurity) GetAuthorizationUrl() string {
	if m != nil {
		return m.AuthorizationUrl
	}
	return ""
}

func (m *Oauth2ImplicitSecurity) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Oauth2ImplicitSecurity) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type Oauth2PasswordSecurity struct {
	Type            string        `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Flow            string        `protobuf:"bytes,2,opt,name=flow,proto3" json:"flow,omitempty"`
	Scopes          *Oauth2Scopes `protobuf:"bytes,3,opt,name=scopes" json:"scopes,omitempty"`
	TokenUrl        string        `protobuf:"bytes,4,opt,name=token_url,json=tokenUrl,proto3" json:"token_url,omitempty"`
	Description     string        `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	VendorExtension []*NamedAny   `protobuf:"bytes,6,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Oauth2PasswordSecurity) Reset()                    { *m = Oauth2PasswordSecurity{} }
func (m *Oauth2PasswordSecurity) String() string            { return proto.CompactTextString(m) }
func (*Oauth2PasswordSecurity) ProtoMessage()               {}
func (*Oauth2PasswordSecurity) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{34} }

func (m *Oauth2PasswordSecurity) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Oauth2PasswordSecurity) GetFlow() string {
	if m != nil {
		return m.Flow
	}
	return ""
}

func (m *Oauth2PasswordSecurity) GetScopes() *Oauth2Scopes {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *Oauth2PasswordSecurity) GetTokenUrl() string {
	if m != nil {
		return m.TokenUrl
	}
	return ""
}

func (m *Oauth2PasswordSecurity) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Oauth2PasswordSecurity) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type Oauth2Scopes struct {
	AdditionalProperties []*NamedString `protobuf:"bytes,1,rep,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
}

func (m *Oauth2Scopes) Reset()                    { *m = Oauth2Scopes{} }
func (m *Oauth2Scopes) String() string            { return proto.CompactTextString(m) }
func (*Oauth2Scopes) ProtoMessage()               {}
func (*Oauth2Scopes) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{35} }

func (m *Oauth2Scopes) GetAdditionalProperties() []*NamedString {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

type Operation struct {
	Tags []string `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
	// A brief summary of the operation.
	Summary string `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
	// A longer description of the operation, GitHub Flavored Markdown is allowed.
	Description  string        `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	ExternalDocs *ExternalDocs `protobuf:"bytes,4,opt,name=external_docs,json=externalDocs" json:"external_docs,omitempty"`
	// A unique identifier of the operation.
	OperationId string `protobuf:"bytes,5,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	// A list of MIME types the API can produce.
	Produces []string `protobuf:"bytes,6,rep,name=produces" json:"produces,omitempty"`
	// A list of MIME types the API can consume.
	Consumes []string `protobuf:"bytes,7,rep,name=consumes" json:"consumes,omitempty"`
	// The parameters needed to send a valid API call.
	Parameters []*ParametersItem `protobuf:"bytes,8,rep,name=parameters" json:"parameters,omitempty"`
	Responses  *Responses        `protobuf:"bytes,9,opt,name=responses" json:"responses,omitempty"`
	// The transfer protocol of the API.
	Schemes         []string               `protobuf:"bytes,10,rep,name=schemes" json:"schemes,omitempty"`
	Deprecated      bool                   `protobuf:"varint,11,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
	Security        []*SecurityRequirement `protobuf:"bytes,12,rep,name=security" json:"security,omitempty"`
	VendorExtension []*NamedAny            `protobuf:"bytes,13,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Operation) Reset()                    { *m = Operation{} }
func (m *Operation) String() string            { return proto.CompactTextString(m) }
func (*Operation) ProtoMessage()               {}
func (*Operation) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{36} }

func (m *Operation) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Operation) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *Operation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Operation) GetExternalDocs() *ExternalDocs {
	if m != nil {
		return m.ExternalDocs
	}
	return nil
}

func (m *Operation) GetOperationId() string {
	if m != nil {
		return m.OperationId
	}
	return ""
}

func (m *Operation) GetProduces() []string {
	if m != nil {
		return m.Produces
	}
	return nil
}

func (m *Operation) GetConsumes() []string {
	if m != nil {
		return m.Consumes
	}
	return nil
}

func (m *Operation) GetParameters() []*ParametersItem {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Operation) GetResponses() *Responses {
	if m != nil {
		return m.Responses
	}
	return nil
}

func (m *Operation) GetSchemes() []string {
	if m != nil {
		return m.Schemes
	}
	return nil
}

func (m *Operation) GetDeprecated() bool {
	if m != nil {
		return m.Deprecated
	}
	return false
}

func (m *Operation) GetSecurity() []*SecurityRequirement {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *Operation) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type Parameter struct {
	// Types that are valid to be assigned to Oneof:
	//	*Parameter_BodyParameter
	//	*Parameter_NonBodyParameter
	Oneof isParameter_Oneof `protobuf_oneof:"oneof"`
}

func (m *Parameter) Reset()                    { *m = Parameter{} }
func (m *Parameter) String() string            { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()               {}
func (*Parameter) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{37} }

type isParameter_Oneof interface {
	isParameter_Oneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Parameter_BodyParameter struct {
	BodyParameter *BodyParameter `protobuf:"bytes,1,opt,name=body_parameter,json=bodyParameter,oneof"`
}
type Parameter_NonBodyParameter struct {
	NonBodyParameter *NonBodyParameter `protobuf:"bytes,2,opt,name=non_body_parameter,json=nonBodyParameter,oneof"`
}

func (*Parameter_BodyParameter) isParameter_Oneof()    {}
func (*Parameter_NonBodyParameter) isParameter_Oneof() {}

func (m *Parameter) GetOneof() isParameter_Oneof {
	if m != nil {
		return m.Oneof
	}
	return nil
}

func (m *Parameter) GetBodyParameter() *BodyParameter {
	if x, ok := m.GetOneof().(*Parameter_BodyParameter); ok {
		return x.BodyParameter
	}
	return nil
}

func (m *Parameter) GetNonBodyParameter() *NonBodyParameter {
	if x, ok := m.GetOneof().(*Parameter_NonBodyParameter); ok {
		return x.NonBodyParameter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Parameter) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Parameter_OneofMarshaler, _Parameter_OneofUnmarshaler, _Parameter_OneofSizer, []interface{}{
		(*Parameter_BodyParameter)(nil),
		(*Parameter_NonBodyParameter)(nil),
	}
}

func _Parameter_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Parameter)
	// oneof
	switch x := m.Oneof.(type) {
	case *Parameter_BodyParameter:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BodyParameter); err != nil {
			return err
		}
	case *Parameter_NonBodyParameter:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NonBodyParameter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Parameter.Oneof has unexpected type %T", x)
	}
	return nil
}

func _Parameter_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Parameter)
	switch tag {
	case 1: // oneof.body_parameter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BodyParameter)
		err := b.DecodeMessage(msg)
		m.Oneof = &Parameter_BodyParameter{msg}
		return true, err
	case 2: // oneof.non_body_parameter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NonBodyParameter)
		err := b.DecodeMessage(msg)
		m.Oneof = &Parameter_NonBodyParameter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Parameter_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Parameter)
	// oneof
	switch x := m.Oneof.(type) {
	case *Parameter_BodyParameter:
		s := proto.Size(x.BodyParameter)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Parameter_NonBodyParameter:
		s := proto.Size(x.NonBodyParameter)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// One or more JSON representations for parameters
type ParameterDefinitions struct {
	AdditionalProperties []*NamedParameter `protobuf:"bytes,1,rep,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
}

func (m *ParameterDefinitions) Reset()                    { *m = ParameterDefinitions{} }
func (m *ParameterDefinitions) String() string            { return proto.CompactTextString(m) }
func (*ParameterDefinitions) ProtoMessage()               {}
func (*ParameterDefinitions) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{38} }

func (m *ParameterDefinitions) GetAdditionalProperties() []*NamedParameter {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

type ParametersItem struct {
	// Types that are valid to be assigned to Oneof:
	//	*ParametersItem_Parameter
	//	*ParametersItem_JsonReference
	Oneof isParametersItem_Oneof `protobuf_oneof:"oneof"`
}

func (m *ParametersItem) Reset()                    { *m = ParametersItem{} }
func (m *ParametersItem) String() string            { return proto.CompactTextString(m) }
func (*ParametersItem) ProtoMessage()               {}
func (*ParametersItem) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{39} }

type isParametersItem_Oneof interface {
	isParametersItem_Oneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ParametersItem_Parameter struct {
	Parameter *Parameter `protobuf:"bytes,1,opt,name=parameter,oneof"`
}
type ParametersItem_JsonReference struct {
	JsonReference *JsonReference `protobuf:"bytes,2,opt,name=json_reference,json=jsonReference,oneof"`
}

func (*ParametersItem_Parameter) isParametersItem_Oneof()     {}
func (*ParametersItem_JsonReference) isParametersItem_Oneof() {}

func (m *ParametersItem) GetOneof() isParametersItem_Oneof {
	if m != nil {
		return m.Oneof
	}
	return nil
}

func (m *ParametersItem) GetParameter() *Parameter {
	if x, ok := m.GetOneof().(*ParametersItem_Parameter); ok {
		return x.Parameter
	}
	return nil
}

func (m *ParametersItem) GetJsonReference() *JsonReference {
	if x, ok := m.GetOneof().(*ParametersItem_JsonReference); ok {
		return x.JsonReference
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ParametersItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ParametersItem_OneofMarshaler, _ParametersItem_OneofUnmarshaler, _ParametersItem_OneofSizer, []interface{}{
		(*ParametersItem_Parameter)(nil),
		(*ParametersItem_JsonReference)(nil),
	}
}

func _ParametersItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ParametersItem)
	// oneof
	switch x := m.Oneof.(type) {
	case *ParametersItem_Parameter:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Parameter); err != nil {
			return err
		}
	case *ParametersItem_JsonReference:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JsonReference); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ParametersItem.Oneof has unexpected type %T", x)
	}
	return nil
}

func _ParametersItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ParametersItem)
	switch tag {
	case 1: // oneof.parameter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Parameter)
		err := b.DecodeMessage(msg)
		m.Oneof = &ParametersItem_Parameter{msg}
		return true, err
	case 2: // oneof.json_reference
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JsonReference)
		err := b.DecodeMessage(msg)
		m.Oneof = &ParametersItem_JsonReference{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ParametersItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ParametersItem)
	// oneof
	switch x := m.Oneof.(type) {
	case *ParametersItem_Parameter:
		s := proto.Size(x.Parameter)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ParametersItem_JsonReference:
		s := proto.Size(x.JsonReference)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PathItem struct {
	XRef    string     `protobuf:"bytes,1,opt,name=_ref,json=Ref,proto3" json:"_ref,omitempty"`
	Get     *Operation `protobuf:"bytes,2,opt,name=get" json:"get,omitempty"`
	Put     *Operation `protobuf:"bytes,3,opt,name=put" json:"put,omitempty"`
	Post    *Operation `protobuf:"bytes,4,opt,name=post" json:"post,omitempty"`
	Delete  *Operation `protobuf:"bytes,5,opt,name=delete" json:"delete,omitempty"`
	Options *Operation `protobuf:"bytes,6,opt,name=options" json:"options,omitempty"`
	Head    *Operation `protobuf:"bytes,7,opt,name=head" json:"head,omitempty"`
	Patch   *Operation `protobuf:"bytes,8,opt,name=patch" json:"patch,omitempty"`
	// The parameters needed to send a valid API call.
	Parameters      []*ParametersItem `protobuf:"bytes,9,rep,name=parameters" json:"parameters,omitempty"`
	VendorExtension []*NamedAny       `protobuf:"bytes,10,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *PathItem) Reset()                    { *m = PathItem{} }
func (m *PathItem) String() string            { return proto.CompactTextString(m) }
func (*PathItem) ProtoMessage()               {}
func (*PathItem) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{40} }

func (m *PathItem) GetXRef() string {
	if m != nil {
		return m.XRef
	}
	return ""
}

func (m *PathItem) GetGet() *Operation {
	if m != nil {
		return m.Get
	}
	return nil
}

func (m *PathItem) GetPut() *Operation {
	if m != nil {
		return m.Put
	}
	return nil
}

func (m *PathItem) GetPost() *Operation {
	if m != nil {
		return m.Post
	}
	return nil
}

func (m *PathItem) GetDelete() *Operation {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *PathItem) GetOptions() *Operation {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *PathItem) GetHead() *Operation {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *PathItem) GetPatch() *Operation {
	if m != nil {
		return m.Patch
	}
	return nil
}

func (m *PathItem) GetParameters() []*ParametersItem {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *PathItem) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type PathParameterSubSchema struct {
	// Determines whether or not this parameter is required or optional.
	Required bool `protobuf:"varint,1,opt,name=required,proto3" json:"required,omitempty"`
	// Determines the location of the parameter.
	In string `protobuf:"bytes,2,opt,name=in,proto3" json:"in,omitempty"`
	// A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// The name of the parameter.
	Name             string           `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Type             string           `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty"`
	Format           string           `protobuf:"bytes,6,opt,name=format,proto3" json:"format,omitempty"`
	Items            *PrimitivesItems `protobuf:"bytes,7,opt,name=items" json:"items,omitempty"`
	CollectionFormat string           `protobuf:"bytes,8,opt,name=collection_format,json=collectionFormat,proto3" json:"collection_format,omitempty"`
	Default          *Any             `protobuf:"bytes,9,opt,name=default" json:"default,omitempty"`
	Maximum          float64          `protobuf:"fixed64,10,opt,name=maximum,proto3" json:"maximum,omitempty"`
	ExclusiveMaximum bool             `protobuf:"varint,11,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
	Minimum          float64          `protobuf:"fixed64,12,opt,name=minimum,proto3" json:"minimum,omitempty"`
	ExclusiveMinimum bool             `protobuf:"varint,13,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
	MaxLength        int64            `protobuf:"varint,14,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	MinLength        int64            `protobuf:"varint,15,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
	Pattern          string           `protobuf:"bytes,16,opt,name=pattern,proto3" json:"pattern,omitempty"`
	MaxItems         int64            `protobuf:"varint,17,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
	MinItems         int64            `protobuf:"varint,18,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
	UniqueItems      bool             `protobuf:"varint,19,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
	Enum             []*Any           `protobuf:"bytes,20,rep,name=enum" json:"enum,omitempty"`
	MultipleOf       float64          `protobuf:"fixed64,21,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
	VendorExtension  []*NamedAny      `protobuf:"bytes,22,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *PathParameterSubSchema) Reset()                    { *m = PathParameterSubSchema{} }
func (m *PathParameterSubSchema) String() string            { return proto.CompactTextString(m) }
func (*PathParameterSubSchema) ProtoMessage()               {}
func (*PathParameterSubSchema) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{41} }

func (m *PathParameterSubSchema) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *PathParameterSubSchema) GetIn() string {
	if m != nil {
		return m.In
	}
	return ""
}

func (m *PathParameterSubSchema) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PathParameterSubSchema) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PathParameterSubSchema) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PathParameterSubSchema) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *PathParameterSubSchema) GetItems() *PrimitivesItems {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *PathParameterSubSchema) GetCollectionFormat() string {
	if m != nil {
		return m.CollectionFormat
	}
	return ""
}

func (m *PathParameterSubSchema) GetDefault() *Any {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *PathParameterSubSchema) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *PathParameterSubSchema) GetExclusiveMaximum() bool {
	if m != nil {
		return m.ExclusiveMaximum
	}
	return false
}

func (m *PathParameterSubSchema) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *PathParameterSubSchema) GetExclusiveMinimum() bool {
	if m != nil {
		return m.ExclusiveMinimum
	}
	return false
}

func (m *PathParameterSubSchema) GetMaxLength() int64 {
	if m != nil {
		return m.MaxLength
	}
	return 0
}

func (m *PathParameterSubSchema) GetMinLength() int64 {
	if m != nil {
		return m.MinLength
	}
	return 0
}

func (m *PathParameterSubSchema) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *PathParameterSubSchema) GetMaxItems() int64 {
	if m != nil {
		return m.MaxItems
	}
	return 0
}

func (m *PathParameterSubSchema) GetMinItems() int64 {
	if m != nil {
		return m.MinItems
	}
	return 0
}

func (m *PathParameterSubSchema) GetUniqueItems() bool {
	if m != nil {
		return m.UniqueItems
	}
	return false
}

func (m *PathParameterSubSchema) GetEnum() []*Any {
	if m != nil {
		return m.Enum
	}
	return nil
}

func (m *PathParameterSubSchema) GetMultipleOf() float64 {
	if m != nil {
		return m.MultipleOf
	}
	return 0
}

func (m *PathParameterSubSchema) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

// Relative paths to the individual endpoints. They must be relative to the 'basePath'.
type Paths struct {
	VendorExtension []*NamedAny      `protobuf:"bytes,1,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
	Path            []*NamedPathItem `protobuf:"bytes,2,rep,name=path" json:"path,omitempty"`
}

func (m *Paths) Reset()                    { *m = Paths{} }
func (m *Paths) String() string            { return proto.CompactTextString(m) }
func (*Paths) ProtoMessage()               {}
func (*Paths) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{42} }

func (m *Paths) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

func (m *Paths) GetPath() []*NamedPathItem {
	if m != nil {
		return m.Path
	}
	return nil
}

type PrimitivesItems struct {
	Type             string           `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Format           string           `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	Items            *PrimitivesItems `protobuf:"bytes,3,opt,name=items" json:"items,omitempty"`
	CollectionFormat string           `protobuf:"bytes,4,opt,name=collection_format,json=collectionFormat,proto3" json:"collection_format,omitempty"`
	Default          *Any             `protobuf:"bytes,5,opt,name=default" json:"default,omitempty"`
	Maximum          float64          `protobuf:"fixed64,6,opt,name=maximum,proto3" json:"maximum,omitempty"`
	ExclusiveMaximum bool             `protobuf:"varint,7,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
	Minimum          float64          `protobuf:"fixed64,8,opt,name=minimum,proto3" json:"minimum,omitempty"`
	ExclusiveMinimum bool             `protobuf:"varint,9,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
	MaxLength        int64            `protobuf:"varint,10,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	MinLength        int64            `protobuf:"varint,11,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
	Pattern          string           `protobuf:"bytes,12,opt,name=pattern,proto3" json:"pattern,omitempty"`
	MaxItems         int64            `protobuf:"varint,13,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
	MinItems         int64            `protobuf:"varint,14,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
	UniqueItems      bool             `protobuf:"varint,15,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
	Enum             []*Any           `protobuf:"bytes,16,rep,name=enum" json:"enum,omitempty"`
	MultipleOf       float64          `protobuf:"fixed64,17,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
	VendorExtension  []*NamedAny      `protobuf:"bytes,18,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *PrimitivesItems) Reset()                    { *m = PrimitivesItems{} }
func (m *PrimitivesItems) String() string            { return proto.CompactTextString(m) }
func (*PrimitivesItems) ProtoMessage()               {}
func (*PrimitivesItems) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{43} }

func (m *PrimitivesItems) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PrimitivesItems) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *PrimitivesItems) GetItems() *PrimitivesItems {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *PrimitivesItems) GetCollectionFormat() string {
	if m != nil {
		return m.CollectionFormat
	}
	return ""
}

func (m *PrimitivesItems) GetDefault() *Any {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *PrimitivesItems) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *PrimitivesItems) GetExclusiveMaximum() bool {
	if m != nil {
		return m.ExclusiveMaximum
	}
	return false
}

func (m *PrimitivesItems) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *PrimitivesItems) GetExclusiveMinimum() bool {
	if m != nil {
		return m.ExclusiveMinimum
	}
	return false
}

func (m *PrimitivesItems) GetMaxLength() int64 {
	if m != nil {
		return m.MaxLength
	}
	return 0
}

func (m *PrimitivesItems) GetMinLength() int64 {
	if m != nil {
		return m.MinLength
	}
	return 0
}

func (m *PrimitivesItems) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *PrimitivesItems) GetMaxItems() int64 {
	if m != nil {
		return m.MaxItems
	}
	return 0
}

func (m *PrimitivesItems) GetMinItems() int64 {
	if m != nil {
		return m.MinItems
	}
	return 0
}

func (m *PrimitivesItems) GetUniqueItems() bool {
	if m != nil {
		return m.UniqueItems
	}
	return false
}

func (m *PrimitivesItems) GetEnum() []*Any {
	if m != nil {
		return m.Enum
	}
	return nil
}

func (m *PrimitivesItems) GetMultipleOf() float64 {
	if m != nil {
		return m.MultipleOf
	}
	return 0
}

func (m *PrimitivesItems) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type Properties struct {
	AdditionalProperties []*NamedSchema `protobuf:"bytes,1,rep,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
}

func (m *Properties) Reset()                    { *m = Properties{} }
func (m *Properties) String() string            { return proto.CompactTextString(m) }
func (*Properties) ProtoMessage()               {}
func (*Properties) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{44} }

func (m *Properties) GetAdditionalProperties() []*NamedSchema {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

type QueryParameterSubSchema struct {
	// Determines whether or not this parameter is required or optional.
	Required bool `protobuf:"varint,1,opt,name=required,proto3" json:"required,omitempty"`
	// Determines the location of the parameter.
	In string `protobuf:"bytes,2,opt,name=in,proto3" json:"in,omitempty"`
	// A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// The name of the parameter.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// allows sending a parameter by name only or with an empty value.
	AllowEmptyValue  bool             `protobuf:"varint,5,opt,name=allow_empty_value,json=allowEmptyValue,proto3" json:"allow_empty_value,omitempty"`
	Type             string           `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	Format           string           `protobuf:"bytes,7,opt,name=format,proto3" json:"format,omitempty"`
	Items            *PrimitivesItems `protobuf:"bytes,8,opt,name=items" json:"items,omitempty"`
	CollectionFormat string           `protobuf:"bytes,9,opt,name=collection_format,json=collectionFormat,proto3" json:"collection_format,omitempty"`
	Default          *Any             `protobuf:"bytes,10,opt,name=default" json:"default,omitempty"`
	Maximum          float64          `protobuf:"fixed64,11,opt,name=maximum,proto3" json:"maximum,omitempty"`
	ExclusiveMaximum bool             `protobuf:"varint,12,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
	Minimum          float64          `protobuf:"fixed64,13,opt,name=minimum,proto3" json:"minimum,omitempty"`
	ExclusiveMinimum bool             `protobuf:"varint,14,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
	MaxLength        int64            `protobuf:"varint,15,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	MinLength        int64            `protobuf:"varint,16,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
	Pattern          string           `protobuf:"bytes,17,opt,name=pattern,proto3" json:"pattern,omitempty"`
	MaxItems         int64            `protobuf:"varint,18,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
	MinItems         int64            `protobuf:"varint,19,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
	UniqueItems      bool             `protobuf:"varint,20,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
	Enum             []*Any           `protobuf:"bytes,21,rep,name=enum" json:"enum,omitempty"`
	MultipleOf       float64          `protobuf:"fixed64,22,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
	VendorExtension  []*NamedAny      `protobuf:"bytes,23,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *QueryParameterSubSchema) Reset()         { *m = QueryParameterSubSchema{} }
func (m *QueryParameterSubSchema) String() string { return proto.CompactTextString(m) }
func (*QueryParameterSubSchema) ProtoMessage()    {}
func (*QueryParameterSubSchema) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenAPIv2, []int{45}
}

func (m *QueryParameterSubSchema) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *QueryParameterSubSchema) GetIn() string {
	if m != nil {
		return m.In
	}
	return ""
}

func (m *QueryParameterSubSchema) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *QueryParameterSubSchema) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryParameterSubSchema) GetAllowEmptyValue() bool {
	if m != nil {
		return m.AllowEmptyValue
	}
	return false
}

func (m *QueryParameterSubSchema) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *QueryParameterSubSchema) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *QueryParameterSubSchema) GetItems() *PrimitivesItems {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *QueryParameterSubSchema) GetCollectionFormat() string {
	if m != nil {
		return m.CollectionFormat
	}
	return ""
}

func (m *QueryParameterSubSchema) GetDefault() *Any {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *QueryParameterSubSchema) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *QueryParameterSubSchema) GetExclusiveMaximum() bool {
	if m != nil {
		return m.ExclusiveMaximum
	}
	return false
}

func (m *QueryParameterSubSchema) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *QueryParameterSubSchema) GetExclusiveMinimum() bool {
	if m != nil {
		return m.ExclusiveMinimum
	}
	return false
}

func (m *QueryParameterSubSchema) GetMaxLength() int64 {
	if m != nil {
		return m.MaxLength
	}
	return 0
}

func (m *QueryParameterSubSchema) GetMinLength() int64 {
	if m != nil {
		return m.MinLength
	}
	return 0
}

func (m *QueryParameterSubSchema) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *QueryParameterSubSchema) GetMaxItems() int64 {
	if m != nil {
		return m.MaxItems
	}
	return 0
}

func (m *QueryParameterSubSchema) GetMinItems() int64 {
	if m != nil {
		return m.MinItems
	}
	return 0
}

func (m *QueryParameterSubSchema) GetUniqueItems() bool {
	if m != nil {
		return m.UniqueItems
	}
	return false
}

func (m *QueryParameterSubSchema) GetEnum() []*Any {
	if m != nil {
		return m.Enum
	}
	return nil
}

func (m *QueryParameterSubSchema) GetMultipleOf() float64 {
	if m != nil {
		return m.MultipleOf
	}
	return 0
}

func (m *QueryParameterSubSchema) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type Response struct {
	Description     string      `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Schema          *SchemaItem `protobuf:"bytes,2,opt,name=schema" json:"schema,omitempty"`
	Headers         *Headers    `protobuf:"bytes,3,opt,name=headers" json:"headers,omitempty"`
	Examples        *Examples   `protobuf:"bytes,4,opt,name=examples" json:"examples,omitempty"`
	VendorExtension []*NamedAny `protobuf:"bytes,5,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{46} }

func (m *Response) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Response) GetSchema() *SchemaItem {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *Response) GetHeaders() *Headers {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Response) GetExamples() *Examples {
	if m != nil {
		return m.Examples
	}
	return nil
}

func (m *Response) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

// One or more JSON representations for parameters
type ResponseDefinitions struct {
	AdditionalProperties []*NamedResponse `protobuf:"bytes,1,rep,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
}

func (m *ResponseDefinitions) Reset()                    { *m = ResponseDefinitions{} }
func (m *ResponseDefinitions) String() string            { return proto.CompactTextString(m) }
func (*ResponseDefinitions) ProtoMessage()               {}
func (*ResponseDefinitions) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{47} }

func (m *ResponseDefinitions) GetAdditionalProperties() []*NamedResponse {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

type ResponseValue struct {
	// Types that are valid to be assigned to Oneof:
	//	*ResponseValue_Response
	//	*ResponseValue_JsonReference
	Oneof isResponseValue_Oneof `protobuf_oneof:"oneof"`
}

func (m *ResponseValue) Reset()                    { *m = ResponseValue{} }
func (m *ResponseValue) String() string            { return proto.CompactTextString(m) }
func (*ResponseValue) ProtoMessage()               {}
func (*ResponseValue) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{48} }

type isResponseValue_Oneof interface {
	isResponseValue_Oneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ResponseValue_Response struct {
	Response *Response `protobuf:"bytes,1,opt,name=response,oneof"`
}
type ResponseValue_JsonReference struct {
	JsonReference *JsonReference `protobuf:"bytes,2,opt,name=json_reference,json=jsonReference,oneof"`
}

func (*ResponseValue_Response) isResponseValue_Oneof()      {}
func (*ResponseValue_JsonReference) isResponseValue_Oneof() {}

func (m *ResponseValue) GetOneof() isResponseValue_Oneof {
	if m != nil {
		return m.Oneof
	}
	return nil
}

func (m *ResponseValue) GetResponse() *Response {
	if x, ok := m.GetOneof().(*ResponseValue_Response); ok {
		return x.Response
	}
	return nil
}

func (m *ResponseValue) GetJsonReference() *JsonReference {
	if x, ok := m.GetOneof().(*ResponseValue_JsonReference); ok {
		return x.JsonReference
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ResponseValue) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ResponseValue_OneofMarshaler, _ResponseValue_OneofUnmarshaler, _ResponseValue_OneofSizer, []interface{}{
		(*ResponseValue_Response)(nil),
		(*ResponseValue_JsonReference)(nil),
	}
}

func _ResponseValue_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ResponseValue)
	// oneof
	switch x := m.Oneof.(type) {
	case *ResponseValue_Response:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Response); err != nil {
			return err
		}
	case *ResponseValue_JsonReference:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JsonReference); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ResponseValue.Oneof has unexpected type %T", x)
	}
	return nil
}

func _ResponseValue_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ResponseValue)
	switch tag {
	case 1: // oneof.response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Response)
		err := b.DecodeMessage(msg)
		m.Oneof = &ResponseValue_Response{msg}
		return true, err
	case 2: // oneof.json_reference
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JsonReference)
		err := b.DecodeMessage(msg)
		m.Oneof = &ResponseValue_JsonReference{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ResponseValue_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ResponseValue)
	// oneof
	switch x := m.Oneof.(type) {
	case *ResponseValue_Response:
		s := proto.Size(x.Response)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseValue_JsonReference:
		s := proto.Size(x.JsonReference)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Response objects names can either be any valid HTTP status code or 'default'.
type Responses struct {
	ResponseCode    []*NamedResponseValue `protobuf:"bytes,1,rep,name=response_code,json=responseCode" json:"response_code,omitempty"`
	VendorExtension []*NamedAny           `protobuf:"bytes,2,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Responses) Reset()                    { *m = Responses{} }
func (m *Responses) String() string            { return proto.CompactTextString(m) }
func (*Responses) ProtoMessage()               {}
func (*Responses) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{49} }

func (m *Responses) GetResponseCode() []*NamedResponseValue {
	if m != nil {
		return m.ResponseCode
	}
	return nil
}

func (m *Responses) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

// A deterministic version of a JSON Schema object.
type Schema struct {
	XRef                 string                    `protobuf:"bytes,1,opt,name=_ref,json=Ref,proto3" json:"_ref,omitempty"`
	Format               string                    `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	Title                string                    `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Description          string                    `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Default              *Any                      `protobuf:"bytes,5,opt,name=default" json:"default,omitempty"`
	MultipleOf           float64                   `protobuf:"fixed64,6,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
	Maximum              float64                   `protobuf:"fixed64,7,opt,name=maximum,proto3" json:"maximum,omitempty"`
	ExclusiveMaximum     bool                      `protobuf:"varint,8,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
	Minimum              float64                   `protobuf:"fixed64,9,opt,name=minimum,proto3" json:"minimum,omitempty"`
	ExclusiveMinimum     bool                      `protobuf:"varint,10,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
	MaxLength            int64                     `protobuf:"varint,11,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	MinLength            int64                     `protobuf:"varint,12,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
	Pattern              string                    `protobuf:"bytes,13,opt,name=pattern,proto3" json:"pattern,omitempty"`
	MaxItems             int64                     `protobuf:"varint,14,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
	MinItems             int64                     `protobuf:"varint,15,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
	UniqueItems          bool                      `protobuf:"varint,16,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
	MaxProperties        int64                     `protobuf:"varint,17,opt,name=max_properties,json=maxProperties,proto3" json:"max_properties,omitempty"`
	MinProperties        int64                     `protobuf:"varint,18,opt,name=min_properties,json=minProperties,proto3" json:"min_properties,omitempty"`
	Required             []string                  `protobuf:"bytes,19,rep,name=required" json:"required,omitempty"`
	Enum                 []*Any                    `protobuf:"bytes,20,rep,name=enum" json:"enum,omitempty"`
	AdditionalProperties *AdditionalPropertiesItem `protobuf:"bytes,21,opt,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
	Type                 *TypeItem                 `protobuf:"bytes,22,opt,name=type" json:"type,omitempty"`
	Items                *ItemsItem                `protobuf:"bytes,23,opt,name=items" json:"items,omitempty"`
	AllOf                []*Schema                 `protobuf:"bytes,24,rep,name=all_of,json=allOf" json:"all_of,omitempty"`
	Properties           *Properties               `protobuf:"bytes,25,opt,name=properties" json:"properties,omitempty"`
	Discriminator        string                    `protobuf:"bytes,26,opt,name=discriminator,proto3" json:"discriminator,omitempty"`
	ReadOnly             bool                      `protobuf:"varint,27,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	Xml                  *Xml                      `protobuf:"bytes,28,opt,name=xml" json:"xml,omitempty"`
	ExternalDocs         *ExternalDocs             `protobuf:"bytes,29,opt,name=external_docs,json=externalDocs" json:"external_docs,omitempty"`
	Example              *Any                      `protobuf:"bytes,30,opt,name=example" json:"example,omitempty"`
	VendorExtension      []*NamedAny               `protobuf:"bytes,31,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Schema) Reset()                    { *m = Schema{} }
func (m *Schema) String() string            { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()               {}
func (*Schema) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{50} }

func (m *Schema) GetXRef() string {
	if m != nil {
		return m.XRef
	}
	return ""
}

func (m *Schema) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *Schema) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Schema) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Schema) GetDefault() *Any {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *Schema) GetMultipleOf() float64 {
	if m != nil {
		return m.MultipleOf
	}
	return 0
}

func (m *Schema) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *Schema) GetExclusiveMaximum() bool {
	if m != nil {
		return m.ExclusiveMaximum
	}
	return false
}

func (m *Schema) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *Schema) GetExclusiveMinimum() bool {
	if m != nil {
		return m.ExclusiveMinimum
	}
	return false
}

func (m *Schema) GetMaxLength() int64 {
	if m != nil {
		return m.MaxLength
	}
	return 0
}

func (m *Schema) GetMinLength() int64 {
	if m != nil {
		return m.MinLength
	}
	return 0
}

func (m *Schema) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *Schema) GetMaxItems() int64 {
	if m != nil {
		return m.MaxItems
	}
	return 0
}

func (m *Schema) GetMinItems() int64 {
	if m != nil {
		return m.MinItems
	}
	return 0
}

func (m *Schema) GetUniqueItems() bool {
	if m != nil {
		return m.UniqueItems
	}
	return false
}

func (m *Schema) GetMaxProperties() int64 {
	if m != nil {
		return m.MaxProperties
	}
	return 0
}

func (m *Schema) GetMinProperties() int64 {
	if m != nil {
		return m.MinProperties
	}
	return 0
}

func (m *Schema) GetRequired() []string {
	if m != nil {
		return m.Required
	}
	return nil
}

func (m *Schema) GetEnum() []*Any {
	if m != nil {
		return m.Enum
	}
	return nil
}

func (m *Schema) GetAdditionalProperties() *AdditionalPropertiesItem {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

func (m *Schema) GetType() *TypeItem {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Schema) GetItems() *ItemsItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Schema) GetAllOf() []*Schema {
	if m != nil {
		return m.AllOf
	}
	return nil
}

func (m *Schema) GetProperties() *Properties {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Schema) GetDiscriminator() string {
	if m != nil {
		return m.Discriminator
	}
	return ""
}

func (m *Schema) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *Schema) GetXml() *Xml {
	if m != nil {
		return m.Xml
	}
	return nil
}

func (m *Schema) GetExternalDocs() *ExternalDocs {
	if m != nil {
		return m.ExternalDocs
	}
	return nil
}

func (m *Schema) GetExample() *Any {
	if m != nil {
		return m.Example
	}
	return nil
}

func (m *Schema) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type SchemaItem struct {
	// Types that are valid to be assigned to Oneof:
	//	*SchemaItem_Schema
	//	*SchemaItem_FileSchema
	Oneof isSchemaItem_Oneof `protobuf_oneof:"oneof"`
}

func (m *SchemaItem) Reset()                    { *m = SchemaItem{} }
func (m *SchemaItem) String() string            { return proto.CompactTextString(m) }
func (*SchemaItem) ProtoMessage()               {}
func (*SchemaItem) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{51} }

type isSchemaItem_Oneof interface {
	isSchemaItem_Oneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SchemaItem_Schema struct {
	Schema *Schema `protobuf:"bytes,1,opt,name=schema,oneof"`
}
type SchemaItem_FileSchema struct {
	FileSchema *FileSchema `protobuf:"bytes,2,opt,name=file_schema,json=fileSchema,oneof"`
}

func (*SchemaItem_Schema) isSchemaItem_Oneof()     {}
func (*SchemaItem_FileSchema) isSchemaItem_Oneof() {}

func (m *SchemaItem) GetOneof() isSchemaItem_Oneof {
	if m != nil {
		return m.Oneof
	}
	return nil
}

func (m *SchemaItem) GetSchema() *Schema {
	if x, ok := m.GetOneof().(*SchemaItem_Schema); ok {
		return x.Schema
	}
	return nil
}

func (m *SchemaItem) GetFileSchema() *FileSchema {
	if x, ok := m.GetOneof().(*SchemaItem_FileSchema); ok {
		return x.FileSchema
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SchemaItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SchemaItem_OneofMarshaler, _SchemaItem_OneofUnmarshaler, _SchemaItem_OneofSizer, []interface{}{
		(*SchemaItem_Schema)(nil),
		(*SchemaItem_FileSchema)(nil),
	}
}

func _SchemaItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SchemaItem)
	// oneof
	switch x := m.Oneof.(type) {
	case *SchemaItem_Schema:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Schema); err != nil {
			return err
		}
	case *SchemaItem_FileSchema:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FileSchema); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SchemaItem.Oneof has unexpected type %T", x)
	}
	return nil
}

func _SchemaItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SchemaItem)
	switch tag {
	case 1: // oneof.schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Schema)
		err := b.DecodeMessage(msg)
		m.Oneof = &SchemaItem_Schema{msg}
		return true, err
	case 2: // oneof.file_schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileSchema)
		err := b.DecodeMessage(msg)
		m.Oneof = &SchemaItem_FileSchema{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SchemaItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SchemaItem)
	// oneof
	switch x := m.Oneof.(type) {
	case *SchemaItem_Schema:
		s := proto.Size(x.Schema)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SchemaItem_FileSchema:
		s := proto.Size(x.FileSchema)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SecurityDefinitions struct {
	AdditionalProperties []*NamedSecurityDefinitionsItem `protobuf:"bytes,1,rep,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
}

func (m *SecurityDefinitions) Reset()                    { *m = SecurityDefinitions{} }
func (m *SecurityDefinitions) String() string            { return proto.CompactTextString(m) }
func (*SecurityDefinitions) ProtoMessage()               {}
func (*SecurityDefinitions) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{52} }

func (m *SecurityDefinitions) GetAdditionalProperties() []*NamedSecurityDefinitionsItem {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

type SecurityDefinitionsItem struct {
	// Types that are valid to be assigned to Oneof:
	//	*SecurityDefinitionsItem_BasicAuthenticationSecurity
	//	*SecurityDefinitionsItem_ApiKeySecurity
	//	*SecurityDefinitionsItem_Oauth2ImplicitSecurity
	//	*SecurityDefinitionsItem_Oauth2PasswordSecurity
	//	*SecurityDefinitionsItem_Oauth2ApplicationSecurity
	//	*SecurityDefinitionsItem_Oauth2AccessCodeSecurity
	Oneof isSecurityDefinitionsItem_Oneof `protobuf_oneof:"oneof"`
}

func (m *SecurityDefinitionsItem) Reset()         { *m = SecurityDefinitionsItem{} }
func (m *SecurityDefinitionsItem) String() string { return proto.CompactTextString(m) }
func (*SecurityDefinitionsItem) ProtoMessage()    {}
func (*SecurityDefinitionsItem) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenAPIv2, []int{53}
}

type isSecurityDefinitionsItem_Oneof interface {
	isSecurityDefinitionsItem_Oneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SecurityDefinitionsItem_BasicAuthenticationSecurity struct {
	BasicAuthenticationSecurity *BasicAuthenticationSecurity `protobuf:"bytes,1,opt,name=basic_authentication_security,json=basicAuthenticationSecurity,oneof"`
}
type SecurityDefinitionsItem_ApiKeySecurity struct {
	ApiKeySecurity *ApiKeySecurity `protobuf:"bytes,2,opt,name=api_key_security,json=apiKeySecurity,oneof"`
}
type SecurityDefinitionsItem_Oauth2ImplicitSecurity struct {
	Oauth2ImplicitSecurity *Oauth2ImplicitSecurity `protobuf:"bytes,3,opt,name=oauth2_implicit_security,json=oauth2ImplicitSecurity,oneof"`
}
type SecurityDefinitionsItem_Oauth2PasswordSecurity struct {
	Oauth2PasswordSecurity *Oauth2PasswordSecurity `protobuf:"bytes,4,opt,name=oauth2_password_security,json=oauth2PasswordSecurity,oneof"`
}
type SecurityDefinitionsItem_Oauth2ApplicationSecurity struct {
	Oauth2ApplicationSecurity *Oauth2ApplicationSecurity `protobuf:"bytes,5,opt,name=oauth2_application_security,json=oauth2ApplicationSecurity,oneof"`
}
type SecurityDefinitionsItem_Oauth2AccessCodeSecurity struct {
	Oauth2AccessCodeSecurity *Oauth2AccessCodeSecurity `protobuf:"bytes,6,opt,name=oauth2_access_code_security,json=oauth2AccessCodeSecurity,oneof"`
}

func (*SecurityDefinitionsItem_BasicAuthenticationSecurity) isSecurityDefinitionsItem_Oneof() {}
func (*SecurityDefinitionsItem_ApiKeySecurity) isSecurityDefinitionsItem_Oneof()              {}
func (*SecurityDefinitionsItem_Oauth2ImplicitSecurity) isSecurityDefinitionsItem_Oneof()      {}
func (*SecurityDefinitionsItem_Oauth2PasswordSecurity) isSecurityDefinitionsItem_Oneof()      {}
func (*SecurityDefinitionsItem_Oauth2ApplicationSecurity) isSecurityDefinitionsItem_Oneof()   {}
func (*SecurityDefinitionsItem_Oauth2AccessCodeSecurity) isSecurityDefinitionsItem_Oneof()    {}

func (m *SecurityDefinitionsItem) GetOneof() isSecurityDefinitionsItem_Oneof {
	if m != nil {
		return m.Oneof
	}
	return nil
}

func (m *SecurityDefinitionsItem) GetBasicAuthenticationSecurity() *BasicAuthenticationSecurity {
	if x, ok := m.GetOneof().(*SecurityDefinitionsItem_BasicAuthenticationSecurity); ok {
		return x.BasicAuthenticationSecurity
	}
	return nil
}

func (m *SecurityDefinitionsItem) GetApiKeySecurity() *ApiKeySecurity {
	if x, ok := m.GetOneof().(*SecurityDefinitionsItem_ApiKeySecurity); ok {
		return x.ApiKeySecurity
	}
	return nil
}

func (m *SecurityDefinitionsItem) GetOauth2ImplicitSecurity() *Oauth2ImplicitSecurity {
	if x, ok := m.GetOneof().(*SecurityDefinitionsItem_Oauth2ImplicitSecurity); ok {
		return x.Oauth2ImplicitSecurity
	}
	return nil
}

func (m *SecurityDefinitionsItem) GetOauth2PasswordSecurity() *Oauth2PasswordSecurity {
	if x, ok := m.GetOneof().(*SecurityDefinitionsItem_Oauth2PasswordSecurity); ok {
		return x.Oauth2PasswordSecurity
	}
	return nil
}

func (m *SecurityDefinitionsItem) GetOauth2ApplicationSecurity() *Oauth2ApplicationSecurity {
	if x, ok := m.GetOneof().(*SecurityDefinitionsItem_Oauth2ApplicationSecurity); ok {
		return x.Oauth2ApplicationSecurity
	}
	return nil
}

func (m *SecurityDefinitionsItem) GetOauth2AccessCodeSecurity() *Oauth2AccessCodeSecurity {
	if x, ok := m.GetOneof().(*SecurityDefinitionsItem_Oauth2AccessCodeSecurity); ok {
		return x.Oauth2AccessCodeSecurity
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SecurityDefinitionsItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SecurityDefinitionsItem_OneofMarshaler, _SecurityDefinitionsItem_OneofUnmarshaler, _SecurityDefinitionsItem_OneofSizer, []interface{}{
		(*SecurityDefinitionsItem_BasicAuthenticationSecurity)(nil),
		(*SecurityDefinitionsItem_ApiKeySecurity)(nil),
		(*SecurityDefinitionsItem_Oauth2ImplicitSecurity)(nil),
		(*SecurityDefinitionsItem_Oauth2PasswordSecurity)(nil),
		(*SecurityDefinitionsItem_Oauth2ApplicationSecurity)(nil),
		(*SecurityDefinitionsItem_Oauth2AccessCodeSecurity)(nil),
	}
}

func _SecurityDefinitionsItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SecurityDefinitionsItem)
	// oneof
	switch x := m.Oneof.(type) {
	case *SecurityDefinitionsItem_BasicAuthenticationSecurity:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BasicAuthenticationSecurity); err != nil {
			return err
		}
	case *SecurityDefinitionsItem_ApiKeySecurity:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ApiKeySecurity); err != nil {
			return err
		}
	case *SecurityDefinitionsItem_Oauth2ImplicitSecurity:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Oauth2ImplicitSecurity); err != nil {
			return err
		}
	case *SecurityDefinitionsItem_Oauth2PasswordSecurity:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Oauth2PasswordSecurity); err != nil {
			return err
		}
	case *SecurityDefinitionsItem_Oauth2ApplicationSecurity:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Oauth2ApplicationSecurity); err != nil {
			return err
		}
	case *SecurityDefinitionsItem_Oauth2AccessCodeSecurity:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Oauth2AccessCodeSecurity); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SecurityDefinitionsItem.Oneof has unexpected type %T", x)
	}
	return nil
}

func _SecurityDefinitionsItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SecurityDefinitionsItem)
	switch tag {
	case 1: // oneof.basic_authentication_security
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BasicAuthenticationSecurity)
		err := b.DecodeMessage(msg)
		m.Oneof = &SecurityDefinitionsItem_BasicAuthenticationSecurity{msg}
		return true, err
	case 2: // oneof.api_key_security
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ApiKeySecurity)
		err := b.DecodeMessage(msg)
		m.Oneof = &SecurityDefinitionsItem_ApiKeySecurity{msg}
		return true, err
	case 3: // oneof.oauth2_implicit_security
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Oauth2ImplicitSecurity)
		err := b.DecodeMessage(msg)
		m.Oneof = &SecurityDefinitionsItem_Oauth2ImplicitSecurity{msg}
		return true, err
	case 4: // oneof.oauth2_password_security
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Oauth2PasswordSecurity)
		err := b.DecodeMessage(msg)
		m.Oneof = &SecurityDefinitionsItem_Oauth2PasswordSecurity{msg}
		return true, err
	case 5: // oneof.oauth2_application_security
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Oauth2ApplicationSecurity)
		err := b.DecodeMessage(msg)
		m.Oneof = &SecurityDefinitionsItem_Oauth2ApplicationSecurity{msg}
		return true, err
	case 6: // oneof.oauth2_access_code_security
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Oauth2AccessCodeSecurity)
		err := b.DecodeMessage(msg)
		m.Oneof = &SecurityDefinitionsItem_Oauth2AccessCodeSecurity{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SecurityDefinitionsItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SecurityDefinitionsItem)
	// oneof
	switch x := m.Oneof.(type) {
	case *SecurityDefinitionsItem_BasicAuthenticationSecurity:
		s := proto.Size(x.BasicAuthenticationSecurity)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityDefinitionsItem_ApiKeySecurity:
		s := proto.Size(x.ApiKeySecurity)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityDefinitionsItem_Oauth2ImplicitSecurity:
		s := proto.Size(x.Oauth2ImplicitSecurity)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityDefinitionsItem_Oauth2PasswordSecurity:
		s := proto.Size(x.Oauth2PasswordSecurity)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityDefinitionsItem_Oauth2ApplicationSecurity:
		s := proto.Size(x.Oauth2ApplicationSecurity)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityDefinitionsItem_Oauth2AccessCodeSecurity:
		s := proto.Size(x.Oauth2AccessCodeSecurity)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SecurityRequirement struct {
	AdditionalProperties []*NamedStringArray `protobuf:"bytes,1,rep,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
}

func (m *SecurityRequirement) Reset()                    { *m = SecurityRequirement{} }
func (m *SecurityRequirement) String() string            { return proto.CompactTextString(m) }
func (*SecurityRequirement) ProtoMessage()               {}
func (*SecurityRequirement) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{54} }

func (m *SecurityRequirement) GetAdditionalProperties() []*NamedStringArray {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

type StringArray struct {
	Value []string `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
}

func (m *StringArray) Reset()                    { *m = StringArray{} }
func (m *StringArray) String() string            { return proto.CompactTextString(m) }
func (*StringArray) ProtoMessage()               {}
func (*StringArray) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{55} }

func (m *StringArray) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

type Tag struct {
	Name            string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description     string        `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	ExternalDocs    *ExternalDocs `protobuf:"bytes,3,opt,name=external_docs,json=externalDocs" json:"external_docs,omitempty"`
	VendorExtension []*NamedAny   `protobuf:"bytes,4,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{56} }

func (m *Tag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Tag) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Tag) GetExternalDocs() *ExternalDocs {
	if m != nil {
		return m.ExternalDocs
	}
	return nil
}

func (m *Tag) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

type TypeItem struct {
	Value []string `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
}

func (m *TypeItem) Reset()                    { *m = TypeItem{} }
func (m *TypeItem) String() string            { return proto.CompactTextString(m) }
func (*TypeItem) ProtoMessage()               {}
func (*TypeItem) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{57} }

func (m *TypeItem) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

// Any property starting with x- is valid.
type VendorExtension struct {
	AdditionalProperties []*NamedAny `protobuf:"bytes,1,rep,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
}

func (m *VendorExtension) Reset()                    { *m = VendorExtension{} }
func (m *VendorExtension) String() string            { return proto.CompactTextString(m) }
func (*VendorExtension) ProtoMessage()               {}
func (*VendorExtension) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{58} }

func (m *VendorExtension) GetAdditionalProperties() []*NamedAny {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

type Xml struct {
	Name            string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Namespace       string      `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Prefix          string      `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Attribute       bool        `protobuf:"varint,4,opt,name=attribute,proto3" json:"attribute,omitempty"`
	Wrapped         bool        `protobuf:"varint,5,opt,name=wrapped,proto3" json:"wrapped,omitempty"`
	VendorExtension []*NamedAny `protobuf:"bytes,6,rep,name=vendor_extension,json=vendorExtension" json:"vendor_extension,omitempty"`
}

func (m *Xml) Reset()                    { *m = Xml{} }
func (m *Xml) String() string            { return proto.CompactTextString(m) }
func (*Xml) ProtoMessage()               {}
func (*Xml) Descriptor() ([]byte, []int) { return fileDescriptorOpenAPIv2, []int{59} }

func (m *Xml) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Xml) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Xml) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Xml) GetAttribute() bool {
	if m != nil {
		return m.Attribute
	}
	return false
}

func (m *Xml) GetWrapped() bool {
	if m != nil {
		return m.Wrapped
	}
	return false
}

func (m *Xml) GetVendorExtension() []*NamedAny {
	if m != nil {
		return m.VendorExtension
	}
	return nil
}

func init() {
	proto.RegisterType((*AdditionalPropertiesItem)(nil), "openapi.v2.AdditionalPropertiesItem")
	proto.RegisterType((*Any)(nil), "openapi.v2.Any")
	proto.RegisterType((*ApiKeySecurity)(nil), "openapi.v2.ApiKeySecurity")
	proto.RegisterType((*BasicAuthenticationSecurity)(nil), "openapi.v2.BasicAuthenticationSecurity")
	proto.RegisterType((*BodyParameter)(nil), "openapi.v2.BodyParameter")
	proto.RegisterType((*Contact)(nil), "openapi.v2.Contact")
	proto.RegisterType((*Default)(nil), "openapi.v2.Default")
	proto.RegisterType((*Definitions)(nil), "openapi.v2.Definitions")
	proto.RegisterType((*Document)(nil), "openapi.v2.Document")
	proto.RegisterType((*Examples)(nil), "openapi.v2.Examples")
	proto.RegisterType((*ExternalDocs)(nil), "openapi.v2.ExternalDocs")
	proto.RegisterType((*FileSchema)(nil), "openapi.v2.FileSchema")
	proto.RegisterType((*FormDataParameterSubSchema)(nil), "openapi.v2.FormDataParameterSubSchema")
	proto.RegisterType((*Header)(nil), "openapi.v2.Header")
	proto.RegisterType((*HeaderParameterSubSchema)(nil), "openapi.v2.HeaderParameterSubSchema")
	proto.RegisterType((*Headers)(nil), "openapi.v2.Headers")
	proto.RegisterType((*Info)(nil), "openapi.v2.Info")
	proto.RegisterType((*ItemsItem)(nil), "openapi.v2.ItemsItem")
	proto.RegisterType((*JsonReference)(nil), "openapi.v2.JsonReference")
	proto.RegisterType((*License)(nil), "openapi.v2.License")
	proto.RegisterType((*NamedAny)(nil), "openapi.v2.NamedAny")
	proto.RegisterType((*NamedHeader)(nil), "openapi.v2.NamedHeader")
	proto.RegisterType((*NamedParameter)(nil), "openapi.v2.NamedParameter")
	proto.RegisterType((*NamedPathItem)(nil), "openapi.v2.NamedPathItem")
	proto.RegisterType((*NamedResponse)(nil), "openapi.v2.NamedResponse")
	proto.RegisterType((*NamedResponseValue)(nil), "openapi.v2.NamedResponseValue")
	proto.RegisterType((*NamedSchema)(nil), "openapi.v2.NamedSchema")
	proto.RegisterType((*NamedSecurityDefinitionsItem)(nil), "openapi.v2.NamedSecurityDefinitionsItem")
	proto.RegisterType((*NamedString)(nil), "openapi.v2.NamedString")
	proto.RegisterType((*NamedStringArray)(nil), "openapi.v2.NamedStringArray")
	proto.RegisterType((*NonBodyParameter)(nil), "openapi.v2.NonBodyParameter")
	proto.RegisterType((*Oauth2AccessCodeSecurity)(nil), "openapi.v2.Oauth2AccessCodeSecurity")
	proto.RegisterType((*Oauth2ApplicationSecurity)(nil), "openapi.v2.Oauth2ApplicationSecurity")
	proto.RegisterType((*Oauth2ImplicitSecurity)(nil), "openapi.v2.Oauth2ImplicitSecurity")
	proto.RegisterType((*Oauth2PasswordSecurity)(nil), "openapi.v2.Oauth2PasswordSecurity")
	proto.RegisterType((*Oauth2Scopes)(nil), "openapi.v2.Oauth2Scopes")
	proto.RegisterType((*Operation)(nil), "openapi.v2.Operation")
	proto.RegisterType((*Parameter)(nil), "openapi.v2.Parameter")
	proto.RegisterType((*ParameterDefinitions)(nil), "openapi.v2.ParameterDefinitions")
	proto.RegisterType((*ParametersItem)(nil), "openapi.v2.ParametersItem")
	proto.RegisterType((*PathItem)(nil), "openapi.v2.PathItem")
	proto.RegisterType((*PathParameterSubSchema)(nil), "openapi.v2.PathParameterSubSchema")
	proto.RegisterType((*Paths)(nil), "openapi.v2.Paths")
	proto.RegisterType((*PrimitivesItems)(nil), "openapi.v2.PrimitivesItems")
	proto.RegisterType((*Properties)(nil), "openapi.v2.Properties")
	proto.RegisterType((*QueryParameterSubSchema)(nil), "openapi.v2.QueryParameterSubSchema")
	proto.RegisterType((*Response)(nil), "openapi.v2.Response")
	proto.RegisterType((*ResponseDefinitions)(nil), "openapi.v2.ResponseDefinitions")
	proto.RegisterType((*ResponseValue)(nil), "openapi.v2.ResponseValue")
	proto.RegisterType((*Responses)(nil), "openapi.v2.Responses")
	proto.RegisterType((*Schema)(nil), "openapi.v2.Schema")
	proto.RegisterType((*SchemaItem)(nil), "openapi.v2.SchemaItem")
	proto.RegisterType((*SecurityDefinitions)(nil), "openapi.v2.SecurityDefinitions")
	proto.RegisterType((*SecurityDefinitionsItem)(nil), "openapi.v2.SecurityDefinitionsItem")
	proto.RegisterType((*SecurityRequirement)(nil), "openapi.v2.SecurityRequirement")
	proto.RegisterType((*StringArray)(nil), "openapi.v2.StringArray")
	proto.RegisterType((*Tag)(nil), "openapi.v2.Tag")
	proto.RegisterType((*TypeItem)(nil), "openapi.v2.TypeItem")
	proto.RegisterType((*VendorExtension)(nil), "openapi.v2.VendorExtension")
	proto.RegisterType((*Xml)(nil), "openapi.v2.Xml")
}
func (m *AdditionalPropertiesItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdditionalPropertiesItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Oneof != nil {
		nn1, err := m.Oneof.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *AdditionalPropertiesItem_Schema) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Schema != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Schema.Size()))
		n2, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *AdditionalPropertiesItem_Boolean) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Boolean {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *Any) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Any) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Value.Size()))
		n3, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Yaml) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Yaml)))
		i += copy(dAtA[i:], m.Yaml)
	}
	return i, nil
}

func (m *ApiKeySecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApiKeySecurity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.In) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.In)))
		i += copy(dAtA[i:], m.In)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BasicAuthenticationSecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicAuthenticationSecurity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BodyParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BodyParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.In) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.In)))
		i += copy(dAtA[i:], m.In)
	}
	if m.Required {
		dAtA[i] = 0x20
		i++
		if m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Schema != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Schema.Size()))
		n4, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x32
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Contact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x22
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Default) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Default) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, msg := range m.AdditionalProperties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Definitions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Definitions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, msg := range m.AdditionalProperties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Document) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Swagger) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Swagger)))
		i += copy(dAtA[i:], m.Swagger)
	}
	if m.Info != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Info.Size()))
		n5, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Host) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.BasePath) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.BasePath)))
		i += copy(dAtA[i:], m.BasePath)
	}
	if len(m.Schemes) > 0 {
		for _, s := range m.Schemes {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Consumes) > 0 {
		for _, s := range m.Consumes {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Produces) > 0 {
		for _, s := range m.Produces {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Paths != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Paths.Size()))
		n6, err := m.Paths.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Definitions != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Definitions.Size()))
		n7, err := m.Definitions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Parameters != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Parameters.Size()))
		n8, err := m.Parameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Responses != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Responses.Size()))
		n9, err := m.Responses.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Security) > 0 {
		for _, msg := range m.Security {
			dAtA[i] = 0x62
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SecurityDefinitions != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.SecurityDefinitions.Size()))
		n10, err := m.SecurityDefinitions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x72
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ExternalDocs != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.ExternalDocs.Size()))
		n11, err := m.ExternalDocs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Examples) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Examples) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, msg := range m.AdditionalProperties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExternalDocs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalDocs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FileSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Format) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Default != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Default.Size()))
		n12, err := m.Default.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Required) > 0 {
		for _, s := range m.Required {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.ReadOnly {
		dAtA[i] = 0x38
		i++
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExternalDocs != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.ExternalDocs.Size()))
		n13, err := m.ExternalDocs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Example != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Example.Size()))
		n14, err := m.Example.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x52
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FormDataParameterSubSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FormDataParameterSubSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Required {
		dAtA[i] = 0x8
		i++
		if m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.In) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.In)))
		i += copy(dAtA[i:], m.In)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.AllowEmptyValue {
		dAtA[i] = 0x28
		i++
		if m.AllowEmptyValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if m.Items != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Items.Size()))
		n15, err := m.Items.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.CollectionFormat) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.CollectionFormat)))
		i += copy(dAtA[i:], m.CollectionFormat)
	}
	if m.Default != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Default.Size()))
		n16, err := m.Default.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Maximum != 0 {
		dAtA[i] = 0x59
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Maximum))))
		i += 8
	}
	if m.ExclusiveMaximum {
		dAtA[i] = 0x60
		i++
		if m.ExclusiveMaximum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x69
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Minimum))))
		i += 8
	}
	if m.ExclusiveMinimum {
		dAtA[i] = 0x70
		i++
		if m.ExclusiveMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxLength != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinLength))
	}
	if len(m.Pattern) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	if m.MaxItems != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinItems))
	}
	if m.UniqueItems {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.UniqueItems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Enum) > 0 {
		for _, msg := range m.Enum {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MultipleOf != 0 {
		dAtA[i] = 0xb1
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MultipleOf))))
		i += 8
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if m.Items != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Items.Size()))
		n17, err := m.Items.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.CollectionFormat) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.CollectionFormat)))
		i += copy(dAtA[i:], m.CollectionFormat)
	}
	if m.Default != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Default.Size()))
		n18, err := m.Default.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Maximum != 0 {
		dAtA[i] = 0x31
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Maximum))))
		i += 8
	}
	if m.ExclusiveMaximum {
		dAtA[i] = 0x38
		i++
		if m.ExclusiveMaximum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x41
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Minimum))))
		i += 8
	}
	if m.ExclusiveMinimum {
		dAtA[i] = 0x48
		i++
		if m.ExclusiveMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxLength != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinLength))
	}
	if len(m.Pattern) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	if m.MaxItems != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinItems))
	}
	if m.UniqueItems {
		dAtA[i] = 0x78
		i++
		if m.UniqueItems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Enum) > 0 {
		for _, msg := range m.Enum {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MultipleOf != 0 {
		dAtA[i] = 0x89
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MultipleOf))))
		i += 8
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HeaderParameterSubSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderParameterSubSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Required {
		dAtA[i] = 0x8
		i++
		if m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.In) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.In)))
		i += copy(dAtA[i:], m.In)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if m.Items != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Items.Size()))
		n19, err := m.Items.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.CollectionFormat) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.CollectionFormat)))
		i += copy(dAtA[i:], m.CollectionFormat)
	}
	if m.Default != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Default.Size()))
		n20, err := m.Default.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Maximum != 0 {
		dAtA[i] = 0x51
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Maximum))))
		i += 8
	}
	if m.ExclusiveMaximum {
		dAtA[i] = 0x58
		i++
		if m.ExclusiveMaximum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x61
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Minimum))))
		i += 8
	}
	if m.ExclusiveMinimum {
		dAtA[i] = 0x68
		i++
		if m.ExclusiveMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxLength != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinLength))
	}
	if len(m.Pattern) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	if m.MaxItems != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinItems))
	}
	if m.UniqueItems {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.UniqueItems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Enum) > 0 {
		for _, msg := range m.Enum {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MultipleOf != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MultipleOf))))
		i += 8
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Headers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Headers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, msg := range m.AdditionalProperties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.TermsOfService) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.TermsOfService)))
		i += copy(dAtA[i:], m.TermsOfService)
	}
	if m.Contact != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Contact.Size()))
		n21, err := m.Contact.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.License != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.License.Size()))
		n22, err := m.License.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ItemsItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemsItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for _, msg := range m.Schema {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *JsonReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JsonReference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.XRef) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.XRef)))
		i += copy(dAtA[i:], m.XRef)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	return i, nil
}

func (m *License) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *License) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NamedAny) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedAny) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Value.Size()))
		n23, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *NamedHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Value.Size()))
		n24, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *NamedParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Value.Size()))
		n25, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *NamedPathItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedPathItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Value.Size()))
		n26, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *NamedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Value.Size()))
		n27, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *NamedResponseValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedResponseValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Value.Size()))
		n28, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *NamedSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Value.Size()))
		n29, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *NamedSecurityDefinitionsItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedSecurityDefinitionsItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Value.Size()))
		n30, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *NamedString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedString) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *NamedStringArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedStringArray) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Value.Size()))
		n31, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *NonBodyParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NonBodyParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Oneof != nil {
		nn32, err := m.Oneof.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn32
	}
	return i, nil
}

func (m *NonBodyParameter_HeaderParameterSubSchema) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HeaderParameterSubSchema != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.HeaderParameterSubSchema.Size()))
		n33, err := m.HeaderParameterSubSchema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *NonBodyParameter_FormDataParameterSubSchema) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FormDataParameterSubSchema != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.FormDataParameterSubSchema.Size()))
		n34, err := m.FormDataParameterSubSchema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *NonBodyParameter_QueryParameterSubSchema) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.QueryParameterSubSchema != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.QueryParameterSubSchema.Size()))
		n35, err := m.QueryParameterSubSchema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *NonBodyParameter_PathParameterSubSchema) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PathParameterSubSchema != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.PathParameterSubSchema.Size()))
		n36, err := m.PathParameterSubSchema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *Oauth2AccessCodeSecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Oauth2AccessCodeSecurity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Flow) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Flow)))
		i += copy(dAtA[i:], m.Flow)
	}
	if m.Scopes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Scopes.Size()))
		n37, err := m.Scopes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.AuthorizationUrl) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.AuthorizationUrl)))
		i += copy(dAtA[i:], m.AuthorizationUrl)
	}
	if len(m.TokenUrl) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.TokenUrl)))
		i += copy(dAtA[i:], m.TokenUrl)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Oauth2ApplicationSecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Oauth2ApplicationSecurity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Flow) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Flow)))
		i += copy(dAtA[i:], m.Flow)
	}
	if m.Scopes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Scopes.Size()))
		n38, err := m.Scopes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if len(m.TokenUrl) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.TokenUrl)))
		i += copy(dAtA[i:], m.TokenUrl)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x32
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Oauth2ImplicitSecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Oauth2ImplicitSecurity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Flow) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Flow)))
		i += copy(dAtA[i:], m.Flow)
	}
	if m.Scopes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Scopes.Size()))
		n39, err := m.Scopes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.AuthorizationUrl) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.AuthorizationUrl)))
		i += copy(dAtA[i:], m.AuthorizationUrl)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x32
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Oauth2PasswordSecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Oauth2PasswordSecurity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Flow) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Flow)))
		i += copy(dAtA[i:], m.Flow)
	}
	if m.Scopes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Scopes.Size()))
		n40, err := m.Scopes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if len(m.TokenUrl) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.TokenUrl)))
		i += copy(dAtA[i:], m.TokenUrl)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x32
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Oauth2Scopes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Oauth2Scopes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, msg := range m.AdditionalProperties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Operation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Operation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Summary) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Summary)))
		i += copy(dAtA[i:], m.Summary)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.ExternalDocs != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.ExternalDocs.Size()))
		n41, err := m.ExternalDocs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if len(m.OperationId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.OperationId)))
		i += copy(dAtA[i:], m.OperationId)
	}
	if len(m.Produces) > 0 {
		for _, s := range m.Produces {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Consumes) > 0 {
		for _, s := range m.Consumes {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Parameters) > 0 {
		for _, msg := range m.Parameters {
			dAtA[i] = 0x42
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Responses != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Responses.Size()))
		n42, err := m.Responses.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if len(m.Schemes) > 0 {
		for _, s := range m.Schemes {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Deprecated {
		dAtA[i] = 0x58
		i++
		if m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Security) > 0 {
		for _, msg := range m.Security {
			dAtA[i] = 0x62
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Parameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Parameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Oneof != nil {
		nn43, err := m.Oneof.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn43
	}
	return i, nil
}

func (m *Parameter_BodyParameter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BodyParameter != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.BodyParameter.Size()))
		n44, err := m.BodyParameter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}
func (m *Parameter_NonBodyParameter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NonBodyParameter != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.NonBodyParameter.Size()))
		n45, err := m.NonBodyParameter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *ParameterDefinitions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParameterDefinitions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, msg := range m.AdditionalProperties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ParametersItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParametersItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Oneof != nil {
		nn46, err := m.Oneof.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn46
	}
	return i, nil
}

func (m *ParametersItem_Parameter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Parameter != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Parameter.Size()))
		n47, err := m.Parameter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}
func (m *ParametersItem_JsonReference) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.JsonReference != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.JsonReference.Size()))
		n48, err := m.JsonReference.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}
func (m *PathItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.XRef) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.XRef)))
		i += copy(dAtA[i:], m.XRef)
	}
	if m.Get != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Get.Size()))
		n49, err := m.Get.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.Put != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Put.Size()))
		n50, err := m.Put.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.Post != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Post.Size()))
		n51, err := m.Post.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.Delete != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Delete.Size()))
		n52, err := m.Delete.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.Options != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Options.Size()))
		n53, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.Head != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Head.Size()))
		n54, err := m.Head.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.Patch != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Patch.Size()))
		n55, err := m.Patch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if len(m.Parameters) > 0 {
		for _, msg := range m.Parameters {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x52
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PathParameterSubSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathParameterSubSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Required {
		dAtA[i] = 0x8
		i++
		if m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.In) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.In)))
		i += copy(dAtA[i:], m.In)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if m.Items != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Items.Size()))
		n56, err := m.Items.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if len(m.CollectionFormat) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.CollectionFormat)))
		i += copy(dAtA[i:], m.CollectionFormat)
	}
	if m.Default != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Default.Size()))
		n57, err := m.Default.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.Maximum != 0 {
		dAtA[i] = 0x51
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Maximum))))
		i += 8
	}
	if m.ExclusiveMaximum {
		dAtA[i] = 0x58
		i++
		if m.ExclusiveMaximum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x61
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Minimum))))
		i += 8
	}
	if m.ExclusiveMinimum {
		dAtA[i] = 0x68
		i++
		if m.ExclusiveMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxLength != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinLength))
	}
	if len(m.Pattern) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	if m.MaxItems != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinItems))
	}
	if m.UniqueItems {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.UniqueItems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Enum) > 0 {
		for _, msg := range m.Enum {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MultipleOf != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MultipleOf))))
		i += 8
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Paths) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Paths) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Path) > 0 {
		for _, msg := range m.Path {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PrimitivesItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimitivesItems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if m.Items != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Items.Size()))
		n58, err := m.Items.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if len(m.CollectionFormat) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.CollectionFormat)))
		i += copy(dAtA[i:], m.CollectionFormat)
	}
	if m.Default != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Default.Size()))
		n59, err := m.Default.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.Maximum != 0 {
		dAtA[i] = 0x31
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Maximum))))
		i += 8
	}
	if m.ExclusiveMaximum {
		dAtA[i] = 0x38
		i++
		if m.ExclusiveMaximum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x41
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Minimum))))
		i += 8
	}
	if m.ExclusiveMinimum {
		dAtA[i] = 0x48
		i++
		if m.ExclusiveMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxLength != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinLength))
	}
	if len(m.Pattern) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	if m.MaxItems != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinItems))
	}
	if m.UniqueItems {
		dAtA[i] = 0x78
		i++
		if m.UniqueItems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Enum) > 0 {
		for _, msg := range m.Enum {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MultipleOf != 0 {
		dAtA[i] = 0x89
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MultipleOf))))
		i += 8
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Properties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Properties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, msg := range m.AdditionalProperties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryParameterSubSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParameterSubSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Required {
		dAtA[i] = 0x8
		i++
		if m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.In) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.In)))
		i += copy(dAtA[i:], m.In)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.AllowEmptyValue {
		dAtA[i] = 0x28
		i++
		if m.AllowEmptyValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if m.Items != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Items.Size()))
		n60, err := m.Items.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if len(m.CollectionFormat) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.CollectionFormat)))
		i += copy(dAtA[i:], m.CollectionFormat)
	}
	if m.Default != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Default.Size()))
		n61, err := m.Default.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.Maximum != 0 {
		dAtA[i] = 0x59
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Maximum))))
		i += 8
	}
	if m.ExclusiveMaximum {
		dAtA[i] = 0x60
		i++
		if m.ExclusiveMaximum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x69
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Minimum))))
		i += 8
	}
	if m.ExclusiveMinimum {
		dAtA[i] = 0x70
		i++
		if m.ExclusiveMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxLength != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinLength))
	}
	if len(m.Pattern) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	if m.MaxItems != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinItems))
	}
	if m.UniqueItems {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.UniqueItems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Enum) > 0 {
		for _, msg := range m.Enum {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MultipleOf != 0 {
		dAtA[i] = 0xb1
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MultipleOf))))
		i += 8
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Schema != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Schema.Size()))
		n62, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.Headers != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Headers.Size()))
		n63, err := m.Headers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.Examples != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Examples.Size()))
		n64, err := m.Examples.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ResponseDefinitions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseDefinitions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, msg := range m.AdditionalProperties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ResponseValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Oneof != nil {
		nn65, err := m.Oneof.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn65
	}
	return i, nil
}

func (m *ResponseValue_Response) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Response != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Response.Size()))
		n66, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	return i, nil
}
func (m *ResponseValue_JsonReference) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.JsonReference != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.JsonReference.Size()))
		n67, err := m.JsonReference.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}
func (m *Responses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Responses) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResponseCode) > 0 {
		for _, msg := range m.ResponseCode {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.XRef) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.XRef)))
		i += copy(dAtA[i:], m.XRef)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Default != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Default.Size()))
		n68, err := m.Default.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if m.MultipleOf != 0 {
		dAtA[i] = 0x31
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MultipleOf))))
		i += 8
	}
	if m.Maximum != 0 {
		dAtA[i] = 0x39
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Maximum))))
		i += 8
	}
	if m.ExclusiveMaximum {
		dAtA[i] = 0x40
		i++
		if m.ExclusiveMaximum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x49
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Minimum))))
		i += 8
	}
	if m.ExclusiveMinimum {
		dAtA[i] = 0x50
		i++
		if m.ExclusiveMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxLength != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinLength))
	}
	if len(m.Pattern) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	if m.MaxItems != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinItems))
	}
	if m.UniqueItems {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.UniqueItems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxProperties != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MaxProperties))
	}
	if m.MinProperties != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.MinProperties))
	}
	if len(m.Required) > 0 {
		for _, s := range m.Required {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Enum) > 0 {
		for _, msg := range m.Enum {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AdditionalProperties != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.AdditionalProperties.Size()))
		n69, err := m.AdditionalProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.Type != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Type.Size()))
		n70, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.Items != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Items.Size()))
		n71, err := m.Items.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if len(m.AllOf) > 0 {
		for _, msg := range m.AllOf {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Properties != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Properties.Size()))
		n72, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if len(m.Discriminator) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Discriminator)))
		i += copy(dAtA[i:], m.Discriminator)
	}
	if m.ReadOnly {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Xml != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Xml.Size()))
		n73, err := m.Xml.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if m.ExternalDocs != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.ExternalDocs.Size()))
		n74, err := m.ExternalDocs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.Example != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Example.Size()))
		n75, err := m.Example.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SchemaItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Oneof != nil {
		nn76, err := m.Oneof.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn76
	}
	return i, nil
}

func (m *SchemaItem_Schema) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Schema != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Schema.Size()))
		n77, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	return i, nil
}
func (m *SchemaItem_FileSchema) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FileSchema != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.FileSchema.Size()))
		n78, err := m.FileSchema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}
func (m *SecurityDefinitions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityDefinitions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, msg := range m.AdditionalProperties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityDefinitionsItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityDefinitionsItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Oneof != nil {
		nn79, err := m.Oneof.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn79
	}
	return i, nil
}

func (m *SecurityDefinitionsItem_BasicAuthenticationSecurity) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BasicAuthenticationSecurity != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.BasicAuthenticationSecurity.Size()))
		n80, err := m.BasicAuthenticationSecurity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	return i, nil
}
func (m *SecurityDefinitionsItem_ApiKeySecurity) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ApiKeySecurity != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.ApiKeySecurity.Size()))
		n81, err := m.ApiKeySecurity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	return i, nil
}
func (m *SecurityDefinitionsItem_Oauth2ImplicitSecurity) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Oauth2ImplicitSecurity != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Oauth2ImplicitSecurity.Size()))
		n82, err := m.Oauth2ImplicitSecurity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	return i, nil
}
func (m *SecurityDefinitionsItem_Oauth2PasswordSecurity) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Oauth2PasswordSecurity != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Oauth2PasswordSecurity.Size()))
		n83, err := m.Oauth2PasswordSecurity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}
func (m *SecurityDefinitionsItem_Oauth2ApplicationSecurity) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Oauth2ApplicationSecurity != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Oauth2ApplicationSecurity.Size()))
		n84, err := m.Oauth2ApplicationSecurity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	return i, nil
}
func (m *SecurityDefinitionsItem_Oauth2AccessCodeSecurity) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Oauth2AccessCodeSecurity != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.Oauth2AccessCodeSecurity.Size()))
		n85, err := m.Oauth2AccessCodeSecurity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	return i, nil
}
func (m *SecurityRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRequirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, msg := range m.AdditionalProperties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StringArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringArray) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.ExternalDocs != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(m.ExternalDocs.Size()))
		n86, err := m.ExternalDocs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x22
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TypeItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *VendorExtension) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VendorExtension) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, msg := range m.AdditionalProperties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Xml) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Xml) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenAPIv2(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if m.Attribute {
		dAtA[i] = 0x20
		i++
		if m.Attribute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Wrapped {
		dAtA[i] = 0x28
		i++
		if m.Wrapped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VendorExtension) > 0 {
		for _, msg := range m.VendorExtension {
			dAtA[i] = 0x32
			i++
			i = encodeVarintOpenAPIv2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintOpenAPIv2(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AdditionalPropertiesItem) Size() (n int) {
	var l int
	_ = l
	if m.Oneof != nil {
		n += m.Oneof.Size()
	}
	return n
}

func (m *AdditionalPropertiesItem_Schema) Size() (n int) {
	var l int
	_ = l
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *AdditionalPropertiesItem_Boolean) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *Any) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *ApiKeySecurity) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.In)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *BasicAuthenticationSecurity) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *BodyParameter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.In)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Required {
		n += 2
	}
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Contact) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Default) Size() (n int) {
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, e := range m.AdditionalProperties {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Definitions) Size() (n int) {
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, e := range m.AdditionalProperties {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Document) Size() (n int) {
	var l int
	_ = l
	l = len(m.Swagger)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.BasePath)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.Schemes) > 0 {
		for _, s := range m.Schemes {
			l = len(s)
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if len(m.Consumes) > 0 {
		for _, s := range m.Consumes {
			l = len(s)
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if len(m.Produces) > 0 {
		for _, s := range m.Produces {
			l = len(s)
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.Paths != nil {
		l = m.Paths.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Definitions != nil {
		l = m.Definitions.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Parameters != nil {
		l = m.Parameters.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Responses != nil {
		l = m.Responses.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.Security) > 0 {
		for _, e := range m.Security {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.SecurityDefinitions != nil {
		l = m.SecurityDefinitions.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.ExternalDocs != nil {
		l = m.ExternalDocs.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Examples) Size() (n int) {
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, e := range m.AdditionalProperties {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *ExternalDocs) Size() (n int) {
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *FileSchema) Size() (n int) {
	var l int
	_ = l
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.Required) > 0 {
		for _, s := range m.Required {
			l = len(s)
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	if m.ExternalDocs != nil {
		l = m.ExternalDocs.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Example != nil {
		l = m.Example.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *FormDataParameterSubSchema) Size() (n int) {
	var l int
	_ = l
	if m.Required {
		n += 2
	}
	l = len(m.In)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.AllowEmptyValue {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Items != nil {
		l = m.Items.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.CollectionFormat)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Maximum != 0 {
		n += 9
	}
	if m.ExclusiveMaximum {
		n += 2
	}
	if m.Minimum != 0 {
		n += 9
	}
	if m.ExclusiveMinimum {
		n += 2
	}
	if m.MaxLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MinLength))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if m.MaxItems != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MinItems))
	}
	if m.UniqueItems {
		n += 3
	}
	if len(m.Enum) > 0 {
		for _, e := range m.Enum {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.MultipleOf != 0 {
		n += 10
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Header) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Items != nil {
		l = m.Items.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.CollectionFormat)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Maximum != 0 {
		n += 9
	}
	if m.ExclusiveMaximum {
		n += 2
	}
	if m.Minimum != 0 {
		n += 9
	}
	if m.ExclusiveMinimum {
		n += 2
	}
	if m.MaxLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MinLength))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.MaxItems != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MinItems))
	}
	if m.UniqueItems {
		n += 2
	}
	if len(m.Enum) > 0 {
		for _, e := range m.Enum {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.MultipleOf != 0 {
		n += 10
	}
	l = len(m.Description)
	if l > 0 {
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *HeaderParameterSubSchema) Size() (n int) {
	var l int
	_ = l
	if m.Required {
		n += 2
	}
	l = len(m.In)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Items != nil {
		l = m.Items.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.CollectionFormat)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Maximum != 0 {
		n += 9
	}
	if m.ExclusiveMaximum {
		n += 2
	}
	if m.Minimum != 0 {
		n += 9
	}
	if m.ExclusiveMinimum {
		n += 2
	}
	if m.MaxLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MinLength))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if m.MaxItems != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MinItems))
	}
	if m.UniqueItems {
		n += 3
	}
	if len(m.Enum) > 0 {
		for _, e := range m.Enum {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.MultipleOf != 0 {
		n += 10
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Headers) Size() (n int) {
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, e := range m.AdditionalProperties {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Info) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.TermsOfService)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Contact != nil {
		l = m.Contact.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.License != nil {
		l = m.License.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *ItemsItem) Size() (n int) {
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *JsonReference) Size() (n int) {
	var l int
	_ = l
	l = len(m.XRef)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *License) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *NamedAny) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *NamedHeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *NamedParameter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *NamedPathItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *NamedResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *NamedResponseValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *NamedSchema) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *NamedSecurityDefinitionsItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *NamedString) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *NamedStringArray) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}

func (m *NonBodyParameter) Size() (n int) {
	var l int
	_ = l
	if m.Oneof != nil {
		n += m.Oneof.Size()
	}
	return n
}

func (m *NonBodyParameter_HeaderParameterSubSchema) Size() (n int) {
	var l int
	_ = l
	if m.HeaderParameterSubSchema != nil {
		l = m.HeaderParameterSubSchema.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *NonBodyParameter_FormDataParameterSubSchema) Size() (n int) {
	var l int
	_ = l
	if m.FormDataParameterSubSchema != nil {
		l = m.FormDataParameterSubSchema.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *NonBodyParameter_QueryParameterSubSchema) Size() (n int) {
	var l int
	_ = l
	if m.QueryParameterSubSchema != nil {
		l = m.QueryParameterSubSchema.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *NonBodyParameter_PathParameterSubSchema) Size() (n int) {
	var l int
	_ = l
	if m.PathParameterSubSchema != nil {
		l = m.PathParameterSubSchema.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *Oauth2AccessCodeSecurity) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Flow)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Scopes != nil {
		l = m.Scopes.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.AuthorizationUrl)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.TokenUrl)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Oauth2ApplicationSecurity) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Flow)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Scopes != nil {
		l = m.Scopes.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.TokenUrl)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Oauth2ImplicitSecurity) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Flow)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Scopes != nil {
		l = m.Scopes.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.AuthorizationUrl)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Oauth2PasswordSecurity) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Flow)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Scopes != nil {
		l = m.Scopes.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.TokenUrl)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Oauth2Scopes) Size() (n int) {
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, e := range m.AdditionalProperties {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Operation) Size() (n int) {
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.ExternalDocs != nil {
		l = m.ExternalDocs.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.OperationId)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.Produces) > 0 {
		for _, s := range m.Produces {
			l = len(s)
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if len(m.Consumes) > 0 {
		for _, s := range m.Consumes {
			l = len(s)
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.Responses != nil {
		l = m.Responses.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.Schemes) > 0 {
		for _, s := range m.Schemes {
			l = len(s)
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.Deprecated {
		n += 2
	}
	if len(m.Security) > 0 {
		for _, e := range m.Security {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Parameter) Size() (n int) {
	var l int
	_ = l
	if m.Oneof != nil {
		n += m.Oneof.Size()
	}
	return n
}

func (m *Parameter_BodyParameter) Size() (n int) {
	var l int
	_ = l
	if m.BodyParameter != nil {
		l = m.BodyParameter.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *Parameter_NonBodyParameter) Size() (n int) {
	var l int
	_ = l
	if m.NonBodyParameter != nil {
		l = m.NonBodyParameter.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *ParameterDefinitions) Size() (n int) {
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, e := range m.AdditionalProperties {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *ParametersItem) Size() (n int) {
	var l int
	_ = l
	if m.Oneof != nil {
		n += m.Oneof.Size()
	}
	return n
}

func (m *ParametersItem_Parameter) Size() (n int) {
	var l int
	_ = l
	if m.Parameter != nil {
		l = m.Parameter.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *ParametersItem_JsonReference) Size() (n int) {
	var l int
	_ = l
	if m.JsonReference != nil {
		l = m.JsonReference.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *PathItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.XRef)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Post != nil {
		l = m.Post.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Patch != nil {
		l = m.Patch.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *PathParameterSubSchema) Size() (n int) {
	var l int
	_ = l
	if m.Required {
		n += 2
	}
	l = len(m.In)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Items != nil {
		l = m.Items.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.CollectionFormat)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Maximum != 0 {
		n += 9
	}
	if m.ExclusiveMaximum {
		n += 2
	}
	if m.Minimum != 0 {
		n += 9
	}
	if m.ExclusiveMinimum {
		n += 2
	}
	if m.MaxLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MinLength))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if m.MaxItems != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MinItems))
	}
	if m.UniqueItems {
		n += 3
	}
	if len(m.Enum) > 0 {
		for _, e := range m.Enum {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.MultipleOf != 0 {
		n += 10
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Paths) Size() (n int) {
	var l int
	_ = l
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if len(m.Path) > 0 {
		for _, e := range m.Path {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *PrimitivesItems) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Items != nil {
		l = m.Items.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.CollectionFormat)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Maximum != 0 {
		n += 9
	}
	if m.ExclusiveMaximum {
		n += 2
	}
	if m.Minimum != 0 {
		n += 9
	}
	if m.ExclusiveMinimum {
		n += 2
	}
	if m.MaxLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MinLength))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.MaxItems != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MinItems))
	}
	if m.UniqueItems {
		n += 2
	}
	if len(m.Enum) > 0 {
		for _, e := range m.Enum {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.MultipleOf != 0 {
		n += 10
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Properties) Size() (n int) {
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, e := range m.AdditionalProperties {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *QueryParameterSubSchema) Size() (n int) {
	var l int
	_ = l
	if m.Required {
		n += 2
	}
	l = len(m.In)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.AllowEmptyValue {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Items != nil {
		l = m.Items.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.CollectionFormat)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Maximum != 0 {
		n += 9
	}
	if m.ExclusiveMaximum {
		n += 2
	}
	if m.Minimum != 0 {
		n += 9
	}
	if m.ExclusiveMinimum {
		n += 2
	}
	if m.MaxLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MinLength))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if m.MaxItems != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MinItems))
	}
	if m.UniqueItems {
		n += 3
	}
	if len(m.Enum) > 0 {
		for _, e := range m.Enum {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.MultipleOf != 0 {
		n += 10
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Headers != nil {
		l = m.Headers.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Examples != nil {
		l = m.Examples.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *ResponseDefinitions) Size() (n int) {
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, e := range m.AdditionalProperties {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *ResponseValue) Size() (n int) {
	var l int
	_ = l
	if m.Oneof != nil {
		n += m.Oneof.Size()
	}
	return n
}

func (m *ResponseValue_Response) Size() (n int) {
	var l int
	_ = l
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *ResponseValue_JsonReference) Size() (n int) {
	var l int
	_ = l
	if m.JsonReference != nil {
		l = m.JsonReference.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *Responses) Size() (n int) {
	var l int
	_ = l
	if len(m.ResponseCode) > 0 {
		for _, e := range m.ResponseCode {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Schema) Size() (n int) {
	var l int
	_ = l
	l = len(m.XRef)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.MultipleOf != 0 {
		n += 9
	}
	if m.Maximum != 0 {
		n += 9
	}
	if m.ExclusiveMaximum {
		n += 2
	}
	if m.Minimum != 0 {
		n += 9
	}
	if m.ExclusiveMinimum {
		n += 2
	}
	if m.MaxLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MaxLength))
	}
	if m.MinLength != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MinLength))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.MaxItems != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MaxItems))
	}
	if m.MinItems != 0 {
		n += 1 + sovOpenAPIv2(uint64(m.MinItems))
	}
	if m.UniqueItems {
		n += 3
	}
	if m.MaxProperties != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MaxProperties))
	}
	if m.MinProperties != 0 {
		n += 2 + sovOpenAPIv2(uint64(m.MinProperties))
	}
	if len(m.Required) > 0 {
		for _, s := range m.Required {
			l = len(s)
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if len(m.Enum) > 0 {
		for _, e := range m.Enum {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.AdditionalProperties != nil {
		l = m.AdditionalProperties.Size()
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Items != nil {
		l = m.Items.Size()
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.AllOf) > 0 {
		for _, e := range m.AllOf {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Discriminator)
	if l > 0 {
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if m.ReadOnly {
		n += 3
	}
	if m.Xml != nil {
		l = m.Xml.Size()
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if m.ExternalDocs != nil {
		l = m.ExternalDocs.Size()
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Example != nil {
		l = m.Example.Size()
		n += 2 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 2 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *SchemaItem) Size() (n int) {
	var l int
	_ = l
	if m.Oneof != nil {
		n += m.Oneof.Size()
	}
	return n
}

func (m *SchemaItem_Schema) Size() (n int) {
	var l int
	_ = l
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *SchemaItem_FileSchema) Size() (n int) {
	var l int
	_ = l
	if m.FileSchema != nil {
		l = m.FileSchema.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *SecurityDefinitions) Size() (n int) {
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, e := range m.AdditionalProperties {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *SecurityDefinitionsItem) Size() (n int) {
	var l int
	_ = l
	if m.Oneof != nil {
		n += m.Oneof.Size()
	}
	return n
}

func (m *SecurityDefinitionsItem_BasicAuthenticationSecurity) Size() (n int) {
	var l int
	_ = l
	if m.BasicAuthenticationSecurity != nil {
		l = m.BasicAuthenticationSecurity.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *SecurityDefinitionsItem_ApiKeySecurity) Size() (n int) {
	var l int
	_ = l
	if m.ApiKeySecurity != nil {
		l = m.ApiKeySecurity.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *SecurityDefinitionsItem_Oauth2ImplicitSecurity) Size() (n int) {
	var l int
	_ = l
	if m.Oauth2ImplicitSecurity != nil {
		l = m.Oauth2ImplicitSecurity.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *SecurityDefinitionsItem_Oauth2PasswordSecurity) Size() (n int) {
	var l int
	_ = l
	if m.Oauth2PasswordSecurity != nil {
		l = m.Oauth2PasswordSecurity.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *SecurityDefinitionsItem_Oauth2ApplicationSecurity) Size() (n int) {
	var l int
	_ = l
	if m.Oauth2ApplicationSecurity != nil {
		l = m.Oauth2ApplicationSecurity.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *SecurityDefinitionsItem_Oauth2AccessCodeSecurity) Size() (n int) {
	var l int
	_ = l
	if m.Oauth2AccessCodeSecurity != nil {
		l = m.Oauth2AccessCodeSecurity.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	return n
}
func (m *SecurityRequirement) Size() (n int) {
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, e := range m.AdditionalProperties {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *StringArray) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Tag) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.ExternalDocs != nil {
		l = m.ExternalDocs.Size()
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *TypeItem) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *VendorExtension) Size() (n int) {
	var l int
	_ = l
	if len(m.AdditionalProperties) > 0 {
		for _, e := range m.AdditionalProperties {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func (m *Xml) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovOpenAPIv2(uint64(l))
	}
	if m.Attribute {
		n += 2
	}
	if m.Wrapped {
		n += 2
	}
	if len(m.VendorExtension) > 0 {
		for _, e := range m.VendorExtension {
			l = e.Size()
			n += 1 + l + sovOpenAPIv2(uint64(l))
		}
	}
	return n
}

func sovOpenAPIv2(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOpenAPIv2(x uint64) (n int) {
	return sovOpenAPIv2(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AdditionalPropertiesItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdditionalPropertiesItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdditionalPropertiesItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Schema{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &AdditionalPropertiesItem_Schema{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boolean", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Oneof = &AdditionalPropertiesItem_Boolean{b}
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Any) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Any: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Any: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &google_protobuf.Any{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApiKeySecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApiKeySecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApiKeySecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicAuthenticationSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicAuthenticationSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicAuthenticationSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BodyParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BodyParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BodyParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &Schema{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Default) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Default: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Default: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalProperties = append(m.AdditionalProperties, &NamedAny{})
			if err := m.AdditionalProperties[len(m.AdditionalProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Definitions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Definitions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Definitions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalProperties = append(m.AdditionalProperties, &NamedSchema{})
			if err := m.AdditionalProperties[len(m.AdditionalProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Document) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swagger", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Swagger = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemes = append(m.Schemes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consumes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Consumes = append(m.Consumes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Produces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Produces = append(m.Produces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Paths == nil {
				m.Paths = &Paths{}
			}
			if err := m.Paths.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definitions == nil {
				m.Definitions = &Definitions{}
			}
			if err := m.Definitions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parameters == nil {
				m.Parameters = &ParameterDefinitions{}
			}
			if err := m.Parameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Responses == nil {
				m.Responses = &ResponseDefinitions{}
			}
			if err := m.Responses.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Security = append(m.Security, &SecurityRequirement{})
			if err := m.Security[len(m.Security)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityDefinitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityDefinitions == nil {
				m.SecurityDefinitions = &SecurityDefinitions{}
			}
			if err := m.SecurityDefinitions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalDocs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalDocs == nil {
				m.ExternalDocs = &ExternalDocs{}
			}
			if err := m.ExternalDocs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Examples) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Examples: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Examples: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalProperties = append(m.AdditionalProperties, &NamedAny{})
			if err := m.AdditionalProperties[len(m.AdditionalProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalDocs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalDocs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalDocs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Any{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Required = append(m.Required, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalDocs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalDocs == nil {
				m.ExternalDocs = &ExternalDocs{}
			}
			if err := m.ExternalDocs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Example", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Example == nil {
				m.Example = &Any{}
			}
			if err := m.Example.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FormDataParameterSubSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FormDataParameterSubSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FormDataParameterSubSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowEmptyValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowEmptyValue = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = &PrimitivesItems{}
			}
			if err := m.Items.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Any{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maximum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Maximum = float64(math.Float64frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMaximum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMaximum = bool(v != 0)
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Minimum = float64(math.Float64frombits(v))
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMinimum = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLength", wireType)
			}
			m.MinLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			m.MaxItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinItems", wireType)
			}
			m.MinItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueItems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueItems = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enum = append(m.Enum, &Any{})
			if err := m.Enum[len(m.Enum)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleOf", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MultipleOf = float64(math.Float64frombits(v))
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = &PrimitivesItems{}
			}
			if err := m.Items.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Any{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maximum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Maximum = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMaximum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMaximum = bool(v != 0)
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Minimum = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMinimum = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLength", wireType)
			}
			m.MinLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			m.MaxItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinItems", wireType)
			}
			m.MinItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueItems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueItems = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enum = append(m.Enum, &Any{})
			if err := m.Enum[len(m.Enum)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleOf", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MultipleOf = float64(math.Float64frombits(v))
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderParameterSubSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderParameterSubSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderParameterSubSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = &PrimitivesItems{}
			}
			if err := m.Items.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Any{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maximum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Maximum = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMaximum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMaximum = bool(v != 0)
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Minimum = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMinimum = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLength", wireType)
			}
			m.MinLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			m.MaxItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinItems", wireType)
			}
			m.MinItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueItems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueItems = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enum = append(m.Enum, &Any{})
			if err := m.Enum[len(m.Enum)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleOf", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MultipleOf = float64(math.Float64frombits(v))
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Headers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Headers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Headers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalProperties = append(m.AdditionalProperties, &NamedHeader{})
			if err := m.AdditionalProperties[len(m.AdditionalProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TermsOfService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TermsOfService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contact == nil {
				m.Contact = &Contact{}
			}
			if err := m.Contact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field License", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.License == nil {
				m.License = &License{}
			}
			if err := m.License.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemsItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, &Schema{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JsonReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JsonReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JsonReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *License) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: License: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: License: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedAny) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedAny: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedAny: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Any{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Header{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Parameter{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedPathItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedPathItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedPathItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &PathItem{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Response{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedResponseValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedResponseValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedResponseValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &ResponseValue{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Schema{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedSecurityDefinitionsItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedSecurityDefinitionsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedSecurityDefinitionsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &SecurityDefinitionsItem{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedStringArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedStringArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedStringArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &StringArray{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NonBodyParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NonBodyParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NonBodyParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderParameterSubSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HeaderParameterSubSchema{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &NonBodyParameter_HeaderParameterSubSchema{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormDataParameterSubSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FormDataParameterSubSchema{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &NonBodyParameter_FormDataParameterSubSchema{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParameterSubSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryParameterSubSchema{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &NonBodyParameter_QueryParameterSubSchema{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathParameterSubSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PathParameterSubSchema{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &NonBodyParameter_PathParameterSubSchema{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Oauth2AccessCodeSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Oauth2AccessCodeSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Oauth2AccessCodeSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scopes == nil {
				m.Scopes = &Oauth2Scopes{}
			}
			if err := m.Scopes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizationUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Oauth2ApplicationSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Oauth2ApplicationSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Oauth2ApplicationSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scopes == nil {
				m.Scopes = &Oauth2Scopes{}
			}
			if err := m.Scopes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Oauth2ImplicitSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Oauth2ImplicitSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Oauth2ImplicitSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scopes == nil {
				m.Scopes = &Oauth2Scopes{}
			}
			if err := m.Scopes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizationUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Oauth2PasswordSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Oauth2PasswordSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Oauth2PasswordSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scopes == nil {
				m.Scopes = &Oauth2Scopes{}
			}
			if err := m.Scopes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Oauth2Scopes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Oauth2Scopes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Oauth2Scopes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalProperties = append(m.AdditionalProperties, &NamedString{})
			if err := m.AdditionalProperties[len(m.AdditionalProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Operation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalDocs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalDocs == nil {
				m.ExternalDocs = &ExternalDocs{}
			}
			if err := m.ExternalDocs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Produces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Produces = append(m.Produces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consumes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Consumes = append(m.Consumes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &ParametersItem{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Responses == nil {
				m.Responses = &Responses{}
			}
			if err := m.Responses.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemes = append(m.Schemes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deprecated = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Security = append(m.Security, &SecurityRequirement{})
			if err := m.Security[len(m.Security)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Parameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyParameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BodyParameter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &Parameter_BodyParameter{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonBodyParameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NonBodyParameter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &Parameter_NonBodyParameter{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParameterDefinitions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParameterDefinitions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParameterDefinitions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalProperties = append(m.AdditionalProperties, &NamedParameter{})
			if err := m.AdditionalProperties[len(m.AdditionalProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParametersItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParametersItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParametersItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Parameter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &ParametersItem_Parameter{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JsonReference{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &ParametersItem_JsonReference{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Get == nil {
				m.Get = &Operation{}
			}
			if err := m.Get.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Put == nil {
				m.Put = &Operation{}
			}
			if err := m.Put.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Post == nil {
				m.Post = &Operation{}
			}
			if err := m.Post.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &Operation{}
			}
			if err := m.Delete.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &Operation{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &Operation{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Patch == nil {
				m.Patch = &Operation{}
			}
			if err := m.Patch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &ParametersItem{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathParameterSubSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathParameterSubSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathParameterSubSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = &PrimitivesItems{}
			}
			if err := m.Items.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Any{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maximum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Maximum = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMaximum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMaximum = bool(v != 0)
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Minimum = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMinimum = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLength", wireType)
			}
			m.MinLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			m.MaxItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinItems", wireType)
			}
			m.MinItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueItems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueItems = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enum = append(m.Enum, &Any{})
			if err := m.Enum[len(m.Enum)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleOf", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MultipleOf = float64(math.Float64frombits(v))
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Paths) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Paths: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Paths: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = append(m.Path, &NamedPathItem{})
			if err := m.Path[len(m.Path)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitivesItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitivesItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitivesItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = &PrimitivesItems{}
			}
			if err := m.Items.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Any{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maximum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Maximum = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMaximum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMaximum = bool(v != 0)
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Minimum = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMinimum = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLength", wireType)
			}
			m.MinLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			m.MaxItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinItems", wireType)
			}
			m.MinItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueItems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueItems = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enum = append(m.Enum, &Any{})
			if err := m.Enum[len(m.Enum)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleOf", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MultipleOf = float64(math.Float64frombits(v))
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Properties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Properties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Properties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalProperties = append(m.AdditionalProperties, &NamedSchema{})
			if err := m.AdditionalProperties[len(m.AdditionalProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParameterSubSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParameterSubSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParameterSubSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowEmptyValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowEmptyValue = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = &PrimitivesItems{}
			}
			if err := m.Items.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Any{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maximum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Maximum = float64(math.Float64frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMaximum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMaximum = bool(v != 0)
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Minimum = float64(math.Float64frombits(v))
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMinimum = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLength", wireType)
			}
			m.MinLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			m.MaxItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinItems", wireType)
			}
			m.MinItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueItems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueItems = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enum = append(m.Enum, &Any{})
			if err := m.Enum[len(m.Enum)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleOf", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MultipleOf = float64(math.Float64frombits(v))
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &SchemaItem{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = &Headers{}
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Examples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Examples == nil {
				m.Examples = &Examples{}
			}
			if err := m.Examples.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseDefinitions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseDefinitions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseDefinitions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalProperties = append(m.AdditionalProperties, &NamedResponse{})
			if err := m.AdditionalProperties[len(m.AdditionalProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Response{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &ResponseValue_Response{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JsonReference{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &ResponseValue_JsonReference{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Responses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Responses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Responses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseCode = append(m.ResponseCode, &NamedResponseValue{})
			if err := m.ResponseCode[len(m.ResponseCode)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Any{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleOf", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MultipleOf = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maximum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Maximum = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMaximum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMaximum = bool(v != 0)
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Minimum = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMinimum = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLength", wireType)
			}
			m.MinLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			m.MaxItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinItems", wireType)
			}
			m.MinItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinItems |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueItems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueItems = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProperties", wireType)
			}
			m.MaxProperties = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProperties |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinProperties", wireType)
			}
			m.MinProperties = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinProperties |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Required = append(m.Required, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enum = append(m.Enum, &Any{})
			if err := m.Enum[len(m.Enum)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = &AdditionalPropertiesItem{}
			}
			if err := m.AdditionalProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &TypeItem{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = &ItemsItem{}
			}
			if err := m.Items.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllOf = append(m.AllOf, &Schema{})
			if err := m.AllOf[len(m.AllOf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &Properties{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discriminator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Discriminator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xml", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Xml == nil {
				m.Xml = &Xml{}
			}
			if err := m.Xml.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalDocs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalDocs == nil {
				m.ExternalDocs = &ExternalDocs{}
			}
			if err := m.ExternalDocs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Example", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Example == nil {
				m.Example = &Any{}
			}
			if err := m.Example.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Schema{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &SchemaItem_Schema{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FileSchema{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &SchemaItem_FileSchema{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityDefinitions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityDefinitions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityDefinitions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalProperties = append(m.AdditionalProperties, &NamedSecurityDefinitionsItem{})
			if err := m.AdditionalProperties[len(m.AdditionalProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityDefinitionsItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityDefinitionsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityDefinitionsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicAuthenticationSecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BasicAuthenticationSecurity{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &SecurityDefinitionsItem_BasicAuthenticationSecurity{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiKeySecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ApiKeySecurity{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &SecurityDefinitionsItem_ApiKeySecurity{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oauth2ImplicitSecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Oauth2ImplicitSecurity{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &SecurityDefinitionsItem_Oauth2ImplicitSecurity{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oauth2PasswordSecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Oauth2PasswordSecurity{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &SecurityDefinitionsItem_Oauth2PasswordSecurity{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oauth2ApplicationSecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Oauth2ApplicationSecurity{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &SecurityDefinitionsItem_Oauth2ApplicationSecurity{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oauth2AccessCodeSecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Oauth2AccessCodeSecurity{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &SecurityDefinitionsItem_Oauth2AccessCodeSecurity{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalProperties = append(m.AdditionalProperties, &NamedStringArray{})
			if err := m.AdditionalProperties[len(m.AdditionalProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalDocs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalDocs == nil {
				m.ExternalDocs = &ExternalDocs{}
			}
			if err := m.ExternalDocs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VendorExtension) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VendorExtension: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VendorExtension: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalProperties = append(m.AdditionalProperties, &NamedAny{})
			if err := m.AdditionalProperties[len(m.AdditionalProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Xml) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Xml: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Xml: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Attribute = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wrapped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wrapped = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorExtension = append(m.VendorExtension, &NamedAny{})
			if err := m.VendorExtension[len(m.VendorExtension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenAPIv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenAPIv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOpenAPIv2(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOpenAPIv2
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpenAPIv2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOpenAPIv2
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOpenAPIv2
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOpenAPIv2(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOpenAPIv2 = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOpenAPIv2   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("OpenAPIv2.proto", fileDescriptorOpenAPIv2) }

var fileDescriptorOpenAPIv2 = []byte{
	// 3147 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x3b, 0x4b, 0x6f, 0x24, 0x57,
	0xd5, 0x5d, 0xfd, 0xee, 0x63, 0x77, 0xbb, 0xa7, 0xec, 0xf1, 0xd4, 0xd8, 0x13, 0x67, 0xe2, 0x49,
	0xbe, 0xcc, 0x4c, 0xbe, 0xf1, 0xe4, 0x73, 0xf4, 0x25, 0x0a, 0x28, 0x02, 0xcf, 0x4b, 0x3d, 0x64,
	0x88, 0x9d, 0xf2, 0x24, 0x24, 0x10, 0x28, 0x5d, 0x77, 0xdf, 0xb6, 0x2b, 0xa9, 0xd7, 0x54, 0x55,
	0x7b, 0xdc, 0x2c, 0x58, 0x80, 0xc4, 0x3a, 0xa0, 0xac, 0x91, 0xc2, 0x02, 0x21, 0x65, 0xc1, 0x8a,
	0x15, 0x7f, 0x20, 0x3b, 0xf8, 0x05, 0x08, 0x85, 0x0d, 0x6c, 0x91, 0x58, 0x21, 0x1e, 0xba, 0xaf,
	0x7a, 0xde, 0xea, 0xc7, 0x78, 0x04, 0x08, 0xbc, 0xea, 0xbe, 0xf7, 0x9c, 0x7b, 0xee, 0xa9, 0x53,
	0xe7, 0x75, 0xcf, 0xb9, 0x05, 0x4b, 0xbb, 0x1e, 0x76, 0x76, 0xf6, 0xee, 0x1f, 0x6f, 0x6f, 0x79,
	0xbe, 0x1b, 0xba, 0x2a, 0xb8, 0x1e, 0x76, 0x90, 0x67, 0x6e, 0x1d, 0x6f, 0xaf, 0x5d, 0x3c, 0x74,
	0xdd, 0x43, 0x0b, 0xdf, 0xa4, 0x90, 0x83, 0xd1, 0xf0, 0x26, 0x72, 0xc6, 0x0c, 0x6d, 0xd3, 0x06,
	0x6d, 0x67, 0x30, 0x30, 0x43, 0xd3, 0x75, 0x90, 0xb5, 0xe7, 0xbb, 0x1e, 0xf6, 0x43, 0x13, 0x07,
	0xf7, 0x43, 0x6c, 0xab, 0xff, 0x0b, 0xf5, 0xa0, 0x7f, 0x84, 0x6d, 0xa4, 0x29, 0x97, 0x95, 0xab,
	0x0b, 0xdb, 0xea, 0x56, 0x4c, 0x73, 0x6b, 0x9f, 0x42, 0x7a, 0x25, 0x9d, 0xe3, 0xa8, 0x6b, 0xd0,
	0x38, 0x70, 0x5d, 0x0b, 0x23, 0x47, 0x2b, 0x5f, 0x56, 0xae, 0x36, 0x7b, 0x25, 0x5d, 0x4c, 0xdc,
	0x6a, 0x40, 0xcd, 0x75, 0xb0, 0x3b, 0xdc, 0xbc, 0x0b, 0x95, 0x1d, 0x67, 0xac, 0x5e, 0x87, 0xda,
	0x31, 0xb2, 0x46, 0x98, 0x13, 0x5e, 0xd9, 0x62, 0x0c, 0x6e, 0x09, 0x06, 0xb7, 0x76, 0x9c, 0xb1,
	0xce, 0x50, 0x54, 0x15, 0xaa, 0x63, 0x64, 0x5b, 0x94, 0x68, 0x4b, 0xa7, 0xff, 0x37, 0x3f, 0x53,
	0xa0, 0xb3, 0xe3, 0x99, 0x6f, 0xe2, 0xf1, 0x3e, 0xee, 0x8f, 0x7c, 0x33, 0x1c, 0x13, 0xb4, 0x70,
	0xec, 0x31, 0x8a, 0x2d, 0x9d, 0xfe, 0x27, 0x73, 0x0e, 0xb2, 0xb1, 0x58, 0x4a, 0xfe, 0xab, 0x1d,
	0x28, 0x9b, 0x8e, 0x56, 0xa1, 0x33, 0x65, 0xd3, 0x51, 0x2f, 0xc3, 0xc2, 0x00, 0x07, 0x7d, 0xdf,
	0xf4, 0x88, 0x0c, 0xb4, 0x2a, 0x05, 0x24, 0xa7, 0xd4, 0xaf, 0x40, 0xf7, 0x18, 0x3b, 0x03, 0xd7,
	0x37, 0xf0, 0x49, 0x88, 0x9d, 0x80, 0xa0, 0xd5, 0x2e, 0x57, 0x28, 0xdf, 0x09, 0x81, 0xbc, 0x85,
	0x6c, 0x3c, 0x20, 0x7c, 0x2f, 0x31, 0xec, 0xbb, 0x02, 0x79, 0xf3, 0x13, 0x05, 0xd6, 0x6f, 0xa1,
	0xc0, 0xec, 0xef, 0x8c, 0xc2, 0x23, 0xec, 0x84, 0x66, 0x1f, 0x11, 0xc2, 0x13, 0x59, 0xcf, 0xb0,
	0x55, 0x9e, 0x8d, 0xad, 0xca, 0x3c, 0x6c, 0xfd, 0x56, 0x81, 0xf6, 0x2d, 0x77, 0x30, 0xde, 0x43,
	0x3e, 0xb2, 0x71, 0x88, 0xfd, 0xec, 0xa6, 0x4a, 0x7e, 0xd3, 0x59, 0x24, 0xba, 0x06, 0x4d, 0x1f,
	0x3f, 0x1a, 0x99, 0x3e, 0x1e, 0x50, 0x71, 0x36, 0xf5, 0x68, 0xac, 0x5e, 0x8f, 0x54, 0xaa, 0x56,
	0xa4, 0x52, 0x91, 0x42, 0xc9, 0x1e, 0xb0, 0x3e, 0xcf, 0x03, 0xfe, 0x50, 0x81, 0xc6, 0x6d, 0xd7,
	0x09, 0x51, 0x3f, 0x8c, 0x18, 0x57, 0x12, 0x8c, 0x77, 0xa1, 0x32, 0xf2, 0x85, 0x62, 0x91, 0xbf,
	0xea, 0x0a, 0xd4, 0xb0, 0x8d, 0x4c, 0x8b, 0x3f, 0x0d, 0x1b, 0x48, 0x19, 0xa9, 0xce, 0xc3, 0xc8,
	0x43, 0x68, 0xdc, 0xc1, 0x43, 0x34, 0xb2, 0x42, 0xf5, 0x3e, 0x9c, 0x47, 0x91, 0xbd, 0x19, 0x5e,
	0x64, 0x70, 0x9a, 0x32, 0x81, 0xe0, 0x0a, 0x92, 0x98, 0xe8, 0xe6, 0xb7, 0x60, 0xe1, 0x0e, 0x1e,
	0x9a, 0x0e, 0x85, 0x04, 0xea, 0x83, 0xc9, 0x94, 0x2f, 0xe4, 0x28, 0x73, 0x71, 0xcb, 0x89, 0xff,
	0xa1, 0x06, 0xcd, 0x3b, 0x6e, 0x7f, 0x64, 0x63, 0x27, 0x54, 0x35, 0x68, 0x04, 0x8f, 0xd1, 0xe1,
	0x21, 0xf6, 0xb9, 0xfc, 0xc4, 0x50, 0x7d, 0x1e, 0xaa, 0xa6, 0x33, 0x74, 0xa9, 0x0c, 0x17, 0xb6,
	0xbb, 0xc9, 0x3d, 0xee, 0x3b, 0x43, 0x57, 0xa7, 0x50, 0x22, 0xfc, 0x23, 0x37, 0x08, 0xb9, 0x54,
	0xe9, 0x7f, 0x75, 0x1d, 0x5a, 0x07, 0x28, 0xc0, 0x86, 0x87, 0xc2, 0x23, 0x6e, 0x75, 0x4d, 0x32,
	0xb1, 0x87, 0xc2, 0x23, 0xba, 0x21, 0xe1, 0x0e, 0x07, 0xd4, 0xd2, 0xc8, 0x86, 0x6c, 0x48, 0x94,
	0xab, 0xef, 0x3a, 0xc1, 0x88, 0x80, 0xea, 0x14, 0x14, 0x8d, 0x09, 0xcc, 0xf3, 0xdd, 0xc1, 0xa8,
	0x8f, 0x03, 0xad, 0xc1, 0x60, 0x62, 0xac, 0xbe, 0x08, 0x35, 0xb2, 0x53, 0xa0, 0x35, 0x29, 0xa7,
	0xe7, 0x92, 0x9c, 0x92, 0x2d, 0x03, 0x9d, 0xc1, 0xd5, 0xd7, 0x89, 0x0d, 0x44, 0x52, 0xd5, 0x5a,
	0x14, 0x3d, 0x25, 0xbc, 0x84, 0xd0, 0xf5, 0x24, 0xae, 0xfa, 0x55, 0x00, 0x4f, 0xd8, 0x52, 0xa0,
	0x01, 0x5d, 0x79, 0x39, 0xbd, 0x11, 0x87, 0x26, 0x49, 0x24, 0xd6, 0xa8, 0x6f, 0x40, 0xcb, 0xc7,
	0x81, 0xe7, 0x3a, 0x01, 0x0e, 0xb4, 0x05, 0x4a, 0xe0, 0xd9, 0x24, 0x01, 0x9d, 0x03, 0x93, 0xeb,
	0xe3, 0x15, 0xea, 0x97, 0xa1, 0x19, 0x70, 0xa7, 0xa2, 0x2d, 0xd2, 0xb7, 0x9e, 0x5a, 0x2d, 0x1c,
	0x8e, 0xce, 0xac, 0x91, 0xbc, 0x5a, 0x3d, 0x5a, 0xa0, 0xea, 0xb0, 0x22, 0xfe, 0x1b, 0x49, 0x09,
	0xb4, 0xf3, 0x6c, 0x08, 0x42, 0x49, 0x36, 0x96, 0x83, 0xfc, 0xa4, 0x7a, 0x05, 0xaa, 0x21, 0x3a,
	0x0c, 0xb4, 0x0e, 0x65, 0x66, 0x29, 0x49, 0xe3, 0x21, 0x3a, 0xd4, 0x29, 0x50, 0x7d, 0x03, 0xda,
	0xc4, 0xae, 0x7c, 0xa2, 0xb6, 0x03, 0xb7, 0x1f, 0x68, 0x4b, 0x74, 0x47, 0x2d, 0x89, 0x7d, 0x97,
	0x23, 0xdc, 0x71, 0xfb, 0x81, 0xbe, 0x88, 0x13, 0x23, 0xa9, 0x75, 0x76, 0xe7, 0xb1, 0xce, 0x77,
	0xa0, 0x79, 0xf7, 0x04, 0xd9, 0x9e, 0x85, 0x83, 0xa7, 0x69, 0x9e, 0x3f, 0x50, 0x60, 0x31, 0xc9,
	0xf6, 0x0c, 0xde, 0x35, 0xef, 0x90, 0x4e, 0xed, 0xe4, 0xff, 0x5e, 0x06, 0xb8, 0x67, 0x5a, 0x98,
	0x19, 0xbb, 0xba, 0x0a, 0xf5, 0xa1, 0xeb, 0xdb, 0x28, 0xe4, 0xdb, 0xf3, 0x11, 0x71, 0x7c, 0xa1,
	0x19, 0x5a, 0xc2, 0xb1, 0xb3, 0x41, 0x96, 0xe3, 0x4a, 0x9e, 0xe3, 0x6b, 0xd0, 0x18, 0x30, 0xcf,
	0x46, 0x6d, 0x38, 0xf3, 0x8e, 0x09, 0x47, 0x02, 0x9e, 0x0a, 0x0b, 0xcc, 0xa8, 0xe3, 0xb0, 0x20,
	0x22, 0x60, 0x3d, 0x11, 0x01, 0xd7, 0x89, 0x2d, 0xa0, 0x81, 0xe1, 0x3a, 0xd6, 0x58, 0x6b, 0x88,
	0x38, 0x82, 0x06, 0xbb, 0x8e, 0x35, 0xce, 0xeb, 0x4c, 0x73, 0x2e, 0x9d, 0xb9, 0x06, 0x0d, 0xcc,
	0x5e, 0x39, 0x37, 0xf0, 0x3c, 0xdb, 0x1c, 0x2e, 0x7d, 0x03, 0x30, 0xcf, 0x1b, 0xf8, 0xac, 0x0e,
	0x6b, 0xf7, 0x5c, 0xdf, 0xbe, 0x83, 0x42, 0x14, 0x39, 0x80, 0xfd, 0xd1, 0xc1, 0xbe, 0x48, 0x9b,
	0x62, 0xb1, 0x28, 0x99, 0x68, 0xc9, 0x22, 0x6b, 0xb9, 0x28, 0x57, 0xa9, 0x14, 0xc7, 0xe7, 0x6a,
	0x22, 0xcc, 0x5d, 0x87, 0x73, 0xc8, 0xb2, 0xdc, 0xc7, 0x06, 0xb6, 0xbd, 0x70, 0x6c, 0xb0, 0xc4,
	0xab, 0x46, 0xb7, 0x5a, 0xa2, 0x80, 0xbb, 0x64, 0xfe, 0x5d, 0x91, 0x6c, 0xe5, 0x5e, 0x44, 0xac,
	0x33, 0x8d, 0x94, 0xce, 0xfc, 0x1f, 0xd4, 0xcc, 0x10, 0xdb, 0x42, 0xf6, 0xeb, 0x29, 0x4f, 0xe7,
	0x9b, 0xb6, 0x19, 0x9a, 0xc7, 0x2c, 0x93, 0x0c, 0x74, 0x86, 0xa9, 0xbe, 0x04, 0xe7, 0xfa, 0xae,
	0x65, 0xe1, 0x3e, 0x61, 0xd6, 0xe0, 0x54, 0x5b, 0x94, 0x6a, 0x37, 0x06, 0xdc, 0x63, 0xf4, 0x13,
	0xba, 0x05, 0x53, 0x74, 0x4b, 0x83, 0x86, 0x8d, 0x4e, 0x4c, 0x7b, 0x64, 0x53, 0xaf, 0xa9, 0xe8,
	0x62, 0x48, 0x76, 0xc4, 0x27, 0x7d, 0x6b, 0x14, 0x98, 0xc7, 0xd8, 0x10, 0x38, 0x8b, 0xf4, 0xe1,
	0xbb, 0x11, 0xe0, 0xeb, 0x1c, 0x99, 0x90, 0x31, 0x1d, 0x8a, 0xd2, 0xe6, 0x64, 0xd8, 0x30, 0x43,
	0x86, 0xe3, 0x74, 0xb2, 0x64, 0x38, 0xf2, 0x33, 0x00, 0x36, 0x3a, 0x31, 0x2c, 0xec, 0x1c, 0x86,
	0x47, 0xd4, 0x9b, 0x55, 0xf4, 0x96, 0x8d, 0x4e, 0x1e, 0xd0, 0x09, 0x0a, 0x36, 0x1d, 0x01, 0xee,
	0x72, 0xb0, 0xe9, 0x70, 0xb0, 0x06, 0x0d, 0x0f, 0x85, 0x44, 0x59, 0xb5, 0x73, 0x2c, 0xd8, 0xf2,
	0x21, 0xb1, 0x08, 0x42, 0x97, 0x09, 0x5d, 0xa5, 0xeb, 0x9a, 0x36, 0x3a, 0xa1, 0x12, 0xa6, 0x40,
	0xd3, 0xe1, 0xc0, 0x65, 0x0e, 0x34, 0x1d, 0x06, 0x7c, 0x0e, 0x16, 0x47, 0x8e, 0xf9, 0x68, 0x84,
	0x39, 0x7c, 0x85, 0x72, 0xbe, 0xc0, 0xe6, 0x18, 0xca, 0x15, 0xa8, 0x62, 0x67, 0x64, 0x6b, 0xe7,
	0xf3, 0xae, 0x9a, 0x88, 0x9a, 0x02, 0xd5, 0x67, 0x61, 0xc1, 0x1e, 0x59, 0xa1, 0xe9, 0x59, 0xd8,
	0x70, 0x87, 0xda, 0x2a, 0x15, 0x12, 0x88, 0xa9, 0xdd, 0xa1, 0xd4, 0x5a, 0x2e, 0xcc, 0x65, 0x2d,
	0x35, 0xa8, 0xf7, 0x30, 0x1a, 0x60, 0x5f, 0x9a, 0x16, 0xc7, 0xba, 0x58, 0x96, 0xeb, 0x62, 0xe5,
	0x74, 0xba, 0x58, 0x9d, 0xae, 0x8b, 0xb5, 0xd9, 0x75, 0xb1, 0x3e, 0x83, 0x2e, 0x36, 0xa6, 0xeb,
	0x62, 0x73, 0x06, 0x5d, 0x6c, 0xcd, 0xa4, 0x8b, 0x30, 0x59, 0x17, 0x17, 0x26, 0xe8, 0xe2, 0xe2,
	0x04, 0x5d, 0x6c, 0x4f, 0xd2, 0xc5, 0xce, 0x14, 0x5d, 0x5c, 0x2a, 0xd6, 0xc5, 0xee, 0x1c, 0xba,
	0x78, 0x2e, 0xa7, 0x8b, 0x19, 0x6f, 0xa9, 0xce, 0x76, 0x84, 0x5a, 0x9e, 0x47, 0x5b, 0xff, 0x5a,
	0x03, 0x8d, 0x69, 0xeb, 0xbf, 0xc4, 0xb3, 0x0b, 0x0b, 0xa9, 0x49, 0x2d, 0xa4, 0x2e, 0xb7, 0x90,
	0xc6, 0xe9, 0x2c, 0xa4, 0x39, 0xdd, 0x42, 0x5a, 0xb3, 0x5b, 0x08, 0xcc, 0x60, 0x21, 0x0b, 0xd3,
	0x2d, 0x64, 0x71, 0x06, 0x0b, 0x69, 0xcf, 0x64, 0x21, 0x9d, 0xc9, 0x16, 0xb2, 0x34, 0xc1, 0x42,
	0xba, 0x13, 0x2c, 0xe4, 0xdc, 0x24, 0x0b, 0x51, 0xa7, 0x58, 0xc8, 0x72, 0xb1, 0x85, 0xac, 0xcc,
	0x61, 0x21, 0xe7, 0x67, 0xf2, 0xd6, 0xab, 0xf3, 0xe8, 0xff, 0x37, 0xa0, 0xc1, 0xd4, 0xff, 0x09,
	0x8e, 0x9f, 0x6c, 0x61, 0x41, 0xf2, 0xfc, 0x69, 0x19, 0xaa, 0xe4, 0x00, 0x19, 0x27, 0xa6, 0x4a,
	0x32, 0x31, 0xd5, 0xa0, 0x71, 0x8c, 0xfd, 0x20, 0xae, 0x8c, 0x88, 0xe1, 0x0c, 0x86, 0x74, 0x15,
	0xba, 0x21, 0xf6, 0xed, 0xc0, 0x70, 0x87, 0x46, 0x80, 0xfd, 0x63, 0xb3, 0x2f, 0x8c, 0xaa, 0x43,
	0xe7, 0x77, 0x87, 0xfb, 0x6c, 0x56, 0xbd, 0x01, 0x8d, 0x3e, 0x2b, 0x1f, 0x70, 0xa7, 0xbf, 0x9c,
	0x7c, 0x08, 0x5e, 0x59, 0xd0, 0x05, 0x0e, 0x41, 0xb7, 0xcc, 0x3e, 0x76, 0x02, 0x96, 0x3e, 0x65,
	0xd0, 0x1f, 0x30, 0x90, 0x2e, 0x70, 0xa4, 0xc2, 0x6f, 0xcc, 0x23, 0xfc, 0xd7, 0xa0, 0x45, 0x95,
	0x81, 0xd6, 0xea, 0xae, 0x27, 0x6a, 0x75, 0x95, 0xc9, 0x85, 0x95, 0xcd, 0x3b, 0xd0, 0xfe, 0x5a,
	0xe0, 0x3a, 0x3a, 0x1e, 0x62, 0x1f, 0x3b, 0x7d, 0xac, 0x9e, 0x83, 0xaa, 0xe1, 0xe3, 0x21, 0x97,
	0x71, 0x45, 0xc7, 0xc3, 0xe9, 0xf5, 0xa7, 0x4d, 0x0f, 0x1a, 0xfc, 0x99, 0x66, 0x2c, 0xae, 0x9c,
	0xfa, 0x2c, 0x73, 0x17, 0x9a, 0x02, 0x28, 0xdd, 0xf2, 0x05, 0x51, 0x55, 0x2c, 0xcb, 0x1d, 0x10,
	0x83, 0x6e, 0xbe, 0x09, 0x0b, 0x09, 0x05, 0x94, 0x52, 0xba, 0x9a, 0xa6, 0x94, 0x12, 0x26, 0xd7,
	0x5b, 0x4e, 0xec, 0x6d, 0xe8, 0x50, 0x62, 0x71, 0x11, 0x4d, 0x46, 0xef, 0xa5, 0x34, 0xbd, 0xf3,
	0xd2, 0xa2, 0x80, 0x20, 0xb9, 0x0b, 0x6d, 0x4e, 0x32, 0x3c, 0xa2, 0xef, 0x56, 0x46, 0xf1, 0x7a,
	0x9a, 0xe2, 0x4a, 0xb6, 0x9e, 0x41, 0x16, 0x66, 0x09, 0x8a, 0xea, 0xc1, 0xdc, 0x04, 0xc5, 0x42,
	0x41, 0xf0, 0x7d, 0x50, 0x53, 0x04, 0xa3, 0xb3, 0x43, 0x8e, 0xea, 0xcd, 0x34, 0xd5, 0x8b, 0x32,
	0xaa, 0x74, 0x75, 0xf6, 0xe5, 0xf0, 0x18, 0x3a, 0xef, 0xcb, 0xe1, 0x9a, 0xce, 0x89, 0xd9, 0x70,
	0x89, 0x11, 0xcb, 0x97, 0x26, 0x0a, 0x05, 0xfb, 0x7a, 0x9a, 0xfa, 0x95, 0x29, 0x75, 0x8f, 0xa4,
	0x9c, 0x5f, 0x13, 0xbc, 0x87, 0xbe, 0xe9, 0x1c, 0x4a, 0xa9, 0xaf, 0x24, 0xa9, 0xb7, 0xc4, 0xc2,
	0x77, 0xa0, 0x9b, 0x58, 0xb8, 0xe3, 0xfb, 0x48, 0xae, 0xe0, 0x37, 0xd2, 0xbc, 0xa5, 0x7c, 0x6a,
	0x62, 0xad, 0x20, 0xfb, 0xcb, 0x0a, 0x74, 0xdf, 0x72, 0x9d, 0x74, 0x8d, 0x17, 0xc3, 0xfa, 0x11,
	0xd5, 0x60, 0x23, 0xaa, 0x3b, 0x19, 0xc1, 0xe8, 0xc0, 0x48, 0x55, 0xfa, 0x9f, 0xcf, 0x2b, 0x7c,
	0x3e, 0xc1, 0xe9, 0x95, 0x74, 0xed, 0xa8, 0x28, 0xf9, 0xb1, 0x60, 0x83, 0x24, 0x0c, 0xc6, 0x00,
	0x85, 0x48, 0xbe, 0x13, 0x7b, 0x86, 0xff, 0x49, 0xee, 0x54, 0x7c, 0x4c, 0xee, 0x95, 0xf4, 0xb5,
	0x61, 0xf1, 0x21, 0xfa, 0x00, 0xd6, 0x1e, 0x8d, 0xb0, 0x3f, 0x96, 0xef, 0x54, 0xc9, 0xbf, 0xc9,
	0xb7, 0x09, 0xb6, 0x74, 0x9b, 0x0b, 0x8f, 0xe4, 0x20, 0xd5, 0x80, 0x8b, 0x1e, 0x0a, 0x8f, 0xe4,
	0x5b, 0xb0, 0xe2, 0xc7, 0x66, 0xd6, 0x0a, 0xa5, 0x3b, 0xac, 0x7a, 0x52, 0x48, 0xdc, 0x24, 0xf9,
	0xb4, 0x0c, 0xda, 0x2e, 0x1a, 0x85, 0x47, 0xdb, 0x3b, 0xfd, 0x3e, 0x0e, 0x82, 0xdb, 0xee, 0x00,
	0x4f, 0xeb, 0x73, 0x0c, 0x2d, 0xf7, 0xb1, 0xa8, 0xca, 0x93, 0xff, 0xea, 0xcb, 0x24, 0x20, 0xb8,
	0x1e, 0x16, 0x47, 0xa2, 0x54, 0x69, 0x84, 0x51, 0xdf, 0xa7, 0x70, 0x9d, 0xe3, 0x91, 0xac, 0x89,
	0x4c, 0xbb, 0xbe, 0xf9, 0x5d, 0xda, 0x9f, 0x30, 0x88, 0xff, 0xe6, 0x07, 0xa2, 0x14, 0xe0, 0x1d,
	0xdf, 0x22, 0x09, 0x4c, 0xe8, 0x7e, 0x84, 0x19, 0x12, 0xcb, 0x3f, 0x9b, 0x74, 0x82, 0x00, 0x33,
	0xc1, 0xa3, 0x3e, 0x5b, 0xe6, 0x3d, 0x57, 0xf0, 0xfb, 0xb3, 0x02, 0x17, 0xb9, 0x8c, 0x3c, 0xcf,
	0x9a, 0xa5, 0xa3, 0xf2, 0x74, 0x84, 0x94, 0x7a, 0xee, 0xea, 0xe4, 0xe7, 0xae, 0xcd, 0xf6, 0xdc,
	0x73, 0xf5, 0x34, 0xbe, 0x5f, 0x86, 0x55, 0xc6, 0xd8, 0x7d, 0x9b, 0x3c, 0xb7, 0x19, 0xfe, 0xbb,
	0x69, 0xc6, 0x3f, 0x41, 0x08, 0x7f, 0x52, 0x84, 0x10, 0xf6, 0x50, 0x10, 0x3c, 0x76, 0xfd, 0xc1,
	0x7f, 0xc1, 0x9b, 0xff, 0x00, 0x16, 0x93, 0x7c, 0x3d, 0x41, 0xbf, 0x87, 0x46, 0x88, 0x82, 0x84,
	0xfb, 0x27, 0x55, 0x68, 0xed, 0x7a, 0xd8, 0x47, 0xe2, 0xb0, 0x49, 0xeb, 0xf6, 0x0a, 0xad, 0xd3,
	0xb2, 0x32, 0xbd, 0x06, 0x8d, 0x60, 0x64, 0xdb, 0xc8, 0x1f, 0x8b, 0x9c, 0x9b, 0x0f, 0x67, 0xc8,
	0xb9, 0x73, 0xe5, 0xda, 0xea, 0x5c, 0xe5, 0xda, 0xe7, 0x60, 0xd1, 0x15, 0xbc, 0x19, 0xe6, 0x40,
	0x88, 0x37, 0x9a, 0xbb, 0x3f, 0x48, 0xf5, 0x7e, 0xea, 0x99, 0xde, 0x4f, 0xb2, 0x67, 0xd4, 0xc8,
	0xf4, 0x8c, 0xbe, 0x94, 0xea, 0xd9, 0x34, 0xa9, 0xe8, 0xd6, 0xa4, 0xe9, 0x19, 0x0b, 0xf5, 0xc9,
	0x6e, 0xcd, 0x2b, 0xc9, 0x6e, 0x4d, 0x2b, 0x9f, 0xd9, 0x89, 0x04, 0x27, 0xd5, 0xa3, 0x49, 0xb4,
	0xb6, 0x20, 0xdd, 0xda, 0xda, 0x00, 0x18, 0x60, 0xcf, 0xc7, 0x7d, 0x14, 0xe2, 0x01, 0x3f, 0xf5,
	0x26, 0x66, 0x4e, 0xd7, 0xdd, 0x91, 0xa9, 0x5f, 0x7b, 0x1e, 0xf5, 0xfb, 0x99, 0x02, 0xad, 0x38,
	0x8b, 0xb8, 0x05, 0x9d, 0x03, 0x77, 0x90, 0x88, 0xb7, 0x3c, 0x71, 0x48, 0x25, 0x78, 0xa9, 0xc4,
	0xa3, 0x57, 0xd2, 0xdb, 0x07, 0xa9, 0x4c, 0xe4, 0x01, 0xa8, 0x8e, 0xeb, 0x18, 0x19, 0x3a, 0x2c,
	0x2d, 0xb8, 0x94, 0x62, 0x2a, 0x93, 0xc3, 0xf4, 0x4a, 0x7a, 0xd7, 0xc9, 0xcc, 0xc5, 0xd1, 0xf3,
	0x10, 0x56, 0x64, 0x7d, 0x36, 0x75, 0x77, 0xb2, 0xbd, 0xac, 0xe5, 0xc4, 0x10, 0x27, 0xe6, 0x72,
	0x93, 0xf9, 0x44, 0x81, 0x4e, 0x5a, 0x3b, 0xd4, 0xff, 0x87, 0x56, 0x56, 0x22, 0xf2, 0x5c, 0xbf,
	0x57, 0xd2, 0x63, 0x4c, 0x22, 0xcd, 0x0f, 0x03, 0xd7, 0x21, 0x67, 0x30, 0x76, 0x22, 0x93, 0xa5,
	0xcb, 0xa9, 0x23, 0x1b, 0x91, 0xe6, 0x87, 0xc9, 0x89, 0xf8, 0xf9, 0x7f, 0x5d, 0x81, 0x66, 0x74,
	0x74, 0x90, 0x9c, 0xec, 0x5e, 0x84, 0xca, 0x21, 0x0e, 0x65, 0x27, 0x91, 0xc8, 0xfe, 0x75, 0x82,
	0x41, 0x10, 0xbd, 0x51, 0xc8, 0xfd, 0x63, 0x11, 0xa2, 0x37, 0x0a, 0xd5, 0x6b, 0x50, 0xf5, 0xdc,
	0x40, 0x74, 0x80, 0x0a, 0x30, 0x29, 0x8a, 0x7a, 0x03, 0xea, 0x03, 0x6c, 0xe1, 0x10, 0xf3, 0x13,
	0x75, 0x01, 0x32, 0x47, 0x52, 0x6f, 0x42, 0xc3, 0xf5, 0x58, 0x1b, 0xb2, 0x3e, 0x09, 0x5f, 0x60,
	0x11, 0x56, 0x48, 0x4a, 0xca, 0x8b, 0x5c, 0x45, 0xac, 0x10, 0x14, 0x72, 0x26, 0xf3, 0x50, 0xd8,
	0x3f, 0xe2, 0xed, 0x8b, 0x02, 0x5c, 0x86, 0x93, 0x71, 0x13, 0xad, 0xb9, 0xdc, 0xc4, 0xa9, 0x3b,
	0x48, 0x7f, 0xa9, 0xc1, 0xaa, 0x3c, 0x9b, 0x3c, 0xab, 0x31, 0x9e, 0xd5, 0x18, 0xff, 0xd3, 0x6b,
	0x8c, 0x8f, 0xa1, 0x46, 0x2f, 0x68, 0x48, 0x29, 0x29, 0x73, 0x50, 0x52, 0x6f, 0x40, 0x95, 0xde,
	0x36, 0x29, 0xd3, 0x45, 0x17, 0x25, 0x0e, 0x9f, 0xd7, 0x4d, 0x28, 0xda, 0xe6, 0x8f, 0x6b, 0xb0,
	0x94, 0xd1, 0xda, 0xb3, 0x9e, 0xd4, 0x59, 0x4f, 0xea, 0x54, 0x3d, 0x29, 0x99, 0x0e, 0xab, 0xf3,
	0x58, 0xc3, 0x37, 0x01, 0xe2, 0x14, 0xe4, 0x29, 0xdf, 0xf9, 0xfa, 0x79, 0x1d, 0x2e, 0x14, 0x14,
	0x46, 0xce, 0xae, 0x29, 0x9c, 0x5d, 0x53, 0x38, 0xbb, 0xa6, 0x10, 0x9b, 0xe1, 0xdf, 0x14, 0x68,
	0x46, 0xe5, 0xf4, 0xe9, 0x17, 0xbb, 0xb6, 0xa2, 0xee, 0x0c, 0x4b, 0xbb, 0x57, 0xf3, 0x35, 0x6b,
	0x1a, 0x78, 0xc4, 0xd5, 0xd7, 0x1b, 0xd0, 0x60, 0x95, 0x55, 0x11, 0x3c, 0x96, 0xf3, 0x05, 0xd9,
	0x40, 0x17, 0x38, 0xea, 0xcb, 0xd0, 0xe4, 0xd7, 0x95, 0xc4, 0xc9, 0x7a, 0x25, 0x7d, 0xb2, 0x66,
	0x30, 0x3d, 0xc2, 0x3a, 0xfd, 0x9d, 0x66, 0x0c, 0xcb, 0x92, 0xcb, 0x88, 0xea, 0x5b, 0x93, 0x1d,
	0x52, 0x3e, 0xe6, 0x46, 0xad, 0x05, 0xb9, 0x4b, 0xfa, 0x58, 0x81, 0x76, 0xba, 0xcb, 0xb0, 0x4d,
	0x1c, 0x11, 0x9b, 0x88, 0x6e, 0x8f, 0x4b, 0xce, 0xdc, 0xbd, 0x92, 0x1e, 0xe1, 0x3d, 0xdd, 0xf3,
	0xd5, 0x8f, 0x14, 0x68, 0x45, 0x27, 0x7b, 0xf5, 0x36, 0xb4, 0xc5, 0x36, 0x46, 0xdf, 0x1d, 0x60,
	0xfe, 0xa0, 0x1b, 0x85, 0x0f, 0xca, 0xba, 0x1d, 0x8b, 0x62, 0xd1, 0x6d, 0x77, 0x20, 0x6f, 0x05,
	0x96, 0xe7, 0x79, 0x1b, 0xbf, 0x68, 0x41, 0x9d, 0x3b, 0x6a, 0xc9, 0x89, 0xaf, 0x28, 0x41, 0x89,
	0x7a, 0xab, 0x95, 0x09, 0x97, 0xfe, 0xaa, 0x13, 0x2f, 0xfd, 0x4d, 0x4b, 0x3c, 0x32, 0x96, 0x58,
	0xcf, 0x59, 0x62, 0xc2, 0x25, 0x36, 0x66, 0x70, 0x89, 0xcd, 0xe9, 0x2e, 0xb1, 0x35, 0x83, 0x4b,
	0x84, 0x99, 0x5c, 0xe2, 0xc2, 0x64, 0x97, 0xb8, 0x38, 0xc1, 0x25, 0xb6, 0x27, 0xb8, 0xc4, 0xce,
	0x24, 0x97, 0xb8, 0x34, 0xc5, 0x25, 0x76, 0xf3, 0x2e, 0xf1, 0x05, 0xe8, 0x10, 0xe2, 0x09, 0x63,
	0x63, 0x27, 0x81, 0xb6, 0x8d, 0x4e, 0x12, 0xb9, 0x02, 0x41, 0x33, 0x9d, 0x24, 0x9a, 0xca, 0xd1,
	0x4c, 0x27, 0x81, 0x96, 0x0c, 0xf4, 0xcb, 0x99, 0x6b, 0x9a, 0x33, 0x9d, 0x08, 0xde, 0x2f, 0x72,
	0x01, 0xe7, 0xf3, 0xad, 0xa5, 0xa2, 0x4f, 0x4f, 0xe4, 0xde, 0x40, 0xbd, 0xca, 0xc3, 0xfe, 0x6a,
	0xde, 0xee, 0x1f, 0x8e, 0x3d, 0xcc, 0x72, 0x77, 0x9a, 0x0c, 0xbc, 0x24, 0x82, 0xfe, 0x85, 0xfc,
	0xe1, 0x3e, 0x6a, 0x9a, 0x8b, 0x70, 0x7f, 0x0d, 0xea, 0xc8, 0xb2, 0x88, 0x7e, 0x6a, 0x85, 0xbd,
	0xf3, 0x1a, 0xb2, 0xac, 0xdd, 0xa1, 0xfa, 0x2a, 0x40, 0xe2, 0x89, 0x2e, 0xe6, 0x9d, 0x79, 0xcc,
	0xad, 0x9e, 0xc0, 0x54, 0x9f, 0x87, 0xf6, 0xc0, 0x24, 0x16, 0x64, 0x9b, 0x0e, 0x0a, 0x5d, 0x5f,
	0x5b, 0xa3, 0x0a, 0x92, 0x9e, 0x4c, 0x5f, 0x79, 0x5d, 0xcf, 0x5c, 0x79, 0x7d, 0x0e, 0x2a, 0x27,
	0xb6, 0xa5, 0x5d, 0xca, 0x5b, 0xdc, 0x7b, 0xb6, 0xa5, 0x13, 0x58, 0xbe, 0xcc, 0xfa, 0xcc, 0x93,
	0xde, 0x8a, 0xdd, 0x78, 0x82, 0x5b, 0xb1, 0xcf, 0xce, 0xe3, 0xb1, 0xbe, 0x07, 0x10, 0xc7, 0xbd,
	0x39, 0xbf, 0x34, 0x7a, 0x1d, 0x16, 0x86, 0xa6, 0x85, 0x8d, 0xe2, 0x90, 0x1a, 0xdf, 0x78, 0xee,
	0x95, 0x74, 0x18, 0x46, 0xa3, 0xd8, 0x8b, 0x87, 0xb0, 0x2c, 0xe9, 0xe6, 0xaa, 0xdf, 0x9e, 0x1c,
	0xbf, 0xae, 0xe6, 0x13, 0xea, 0x82, 0x96, 0xb0, 0x3c, 0x9c, 0xfd, 0xb1, 0x0a, 0x17, 0x8a, 0x9a,
	0xd1, 0x36, 0x3c, 0x73, 0x80, 0x02, 0xb3, 0x6f, 0xa0, 0xd4, 0x57, 0x42, 0x46, 0x54, 0xf3, 0x65,
	0xa2, 0x79, 0x31, 0x55, 0x61, 0x2d, 0xfe, 0xaa, 0xa8, 0x57, 0xd2, 0xd7, 0x0f, 0x26, 0x7c, 0x74,
	0x74, 0x0f, 0xba, 0xc8, 0x33, 0x8d, 0x8f, 0xf0, 0x38, 0xde, 0x81, 0x49, 0x32, 0x55, 0xd7, 0x4a,
	0x7f, 0x65, 0xd5, 0x2b, 0xe9, 0x1d, 0x94, 0xfe, 0xee, 0xea, 0x3b, 0xa0, 0xb9, 0xb4, 0x2d, 0x61,
	0x98, 0xbc, 0x21, 0x15, 0xd3, 0xab, 0xe4, 0xbb, 0xa2, 0xf2, 0xde, 0x55, 0xaf, 0xa4, 0xaf, 0xba,
	0xf2, 0xae, 0x56, 0x4c, 0xdf, 0xe3, 0xbd, 0x9e, 0x98, 0x7e, 0xb5, 0x88, 0x7e, 0xb6, 0x2d, 0x14,
	0xd3, 0xcf, 0x35, 0x8c, 0x0e, 0x61, 0x9d, 0xd3, 0x47, 0x71, 0x23, 0x31, 0xde, 0x82, 0x05, 0xb8,
	0x17, 0xf2, 0x5b, 0x48, 0xda, 0x8e, 0xbd, 0x92, 0x7e, 0xd1, 0x2d, 0xec, 0x49, 0xe2, 0x78, 0x23,
	0xda, 0xd5, 0xa5, 0xe9, 0x42, 0xbc, 0x51, 0x3d, 0xef, 0x1d, 0x8b, 0x7a, 0xc0, 0xbd, 0x92, 0xce,
	0x65, 0x92, 0x87, 0xc5, 0x1a, 0x7e, 0x14, 0x6b, 0x78, 0xa2, 0x25, 0xa0, 0xbe, 0x3d, 0x59, 0xc3,
	0x2f, 0x15, 0xb4, 0x8d, 0xd8, 0xc5, 0x02, 0xb9, 0x56, 0x5f, 0x81, 0x85, 0xe4, 0xcd, 0x85, 0x95,
	0xf8, 0xe3, 0xbe, 0x4a, 0x7c, 0xc7, 0xe1, 0x57, 0x0a, 0x54, 0x1e, 0x22, 0xf9, 0xad, 0x88, 0xe9,
	0x1f, 0xbb, 0xe5, 0x3c, 0x5b, 0xe5, 0xd4, 0xdf, 0x88, 0xcc, 0xf5, 0x05, 0xd7, 0x65, 0x68, 0x8a,
	0x08, 0x53, 0xf0, 0x7c, 0x1f, 0xc0, 0xd2, 0xbb, 0x99, 0x7a, 0xd3, 0x53, 0xfc, 0x98, 0xe4, 0x73,
	0x05, 0x2a, 0xef, 0xd9, 0x96, 0x54, 0x7a, 0x97, 0xa0, 0x45, 0x7e, 0x03, 0x0f, 0xf5, 0xc5, 0xbd,
	0x92, 0x78, 0x82, 0x24, 0x7f, 0x9e, 0x8f, 0x87, 0xe6, 0x09, 0xcf, 0xf2, 0xf8, 0x88, 0xac, 0x42,
	0x61, 0xe8, 0x9b, 0x07, 0xa3, 0x10, 0xf3, 0xcf, 0xf4, 0xe2, 0x09, 0x92, 0xca, 0x3c, 0xf6, 0x91,
	0xe7, 0xe1, 0x01, 0x3f, 0x82, 0x8b, 0xe1, 0xa9, 0xfb, 0x98, 0xb7, 0x5e, 0xfd, 0xfc, 0x8b, 0x0d,
	0xe5, 0x37, 0x5f, 0x6c, 0x28, 0xbf, 0xfb, 0x62, 0x43, 0xf9, 0xf8, 0xf7, 0x1b, 0x25, 0xe8, 0xb8,
	0xfe, 0xa1, 0x58, 0x6b, 0x1c, 0x6f, 0xdf, 0x5a, 0xe4, 0xdf, 0xb2, 0xee, 0xf9, 0x6e, 0xe8, 0xee,
	0x29, 0x3f, 0x2d, 0x57, 0x76, 0x77, 0xf6, 0x0f, 0xea, 0xf4, 0xe3, 0xd0, 0x57, 0xfe, 0x11, 0x00,
	0x00, 0xff, 0xff, 0x64, 0x35, 0xff, 0xa7, 0xea, 0x3a, 0x00, 0x00,
}
