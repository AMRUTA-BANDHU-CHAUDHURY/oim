// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: oim.proto

/*
	Package oim is a generated protocol buffer package.

	It is generated from these files:
		oim.proto

	It has these top-level messages:
		RegisterControllerRequest
		RegisterControllerReply
		GetControllerRequest
		GetControllerReply
		DBEntry
		MapVolumeRequest
		MallocParams
		CephParams
		MapVolumeReply
		PCIAddress
		SCSIDisk
		UnmapVolumeRequest
		UnmapVolumeReply
		ProvisionMallocBDevRequest
		ProvisionMallocBDevReply
		CheckMallocBDevRequest
		CheckMallocBDevReply
*/
package oim

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/types"

import "context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type RegisterControllerRequest struct {
	// An identifier for the OIM controller which is unique
	// among all controllers connected to the OIM registry.
	// The host name of each compute node might be used here
	// if it is known to be unique.
	ControllerId string `protobuf:"bytes,1,opt,name=controller_id,json=controllerId,proto3" json:"controller_id,omitempty"`
	// A string that can be used for grpc.Dial to connect
	// to the OIM controller.
	// See https://github.com/grpc/grpc/blob/master/doc/naming.md.
	// An empty string removes the database entry.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *RegisterControllerRequest) Reset()                    { *m = RegisterControllerRequest{} }
func (m *RegisterControllerRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterControllerRequest) ProtoMessage()               {}
func (*RegisterControllerRequest) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{0} }

func (m *RegisterControllerRequest) GetControllerId() string {
	if m != nil {
		return m.ControllerId
	}
	return ""
}

func (m *RegisterControllerRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type RegisterControllerReply struct {
}

func (m *RegisterControllerReply) Reset()                    { *m = RegisterControllerReply{} }
func (m *RegisterControllerReply) String() string            { return proto.CompactTextString(m) }
func (*RegisterControllerReply) ProtoMessage()               {}
func (*RegisterControllerReply) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{1} }

type GetControllerRequest struct {
}

func (m *GetControllerRequest) Reset()                    { *m = GetControllerRequest{} }
func (m *GetControllerRequest) String() string            { return proto.CompactTextString(m) }
func (*GetControllerRequest) ProtoMessage()               {}
func (*GetControllerRequest) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{2} }

type GetControllerReply struct {
	// All current registry DB entries.
	Entries []*DBEntry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *GetControllerReply) Reset()                    { *m = GetControllerReply{} }
func (m *GetControllerReply) String() string            { return proto.CompactTextString(m) }
func (*GetControllerReply) ProtoMessage()               {}
func (*GetControllerReply) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{3} }

func (m *GetControllerReply) GetEntries() []*DBEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type DBEntry struct {
	// The unique key under which the OIM controller is registered.
	ControllerId string `protobuf:"bytes,1,opt,name=controller_id,json=controllerId,proto3" json:"controller_id,omitempty"`
	// The grpc.Dial target for connecting to the OIM controller.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *DBEntry) Reset()                    { *m = DBEntry{} }
func (m *DBEntry) String() string            { return proto.CompactTextString(m) }
func (*DBEntry) ProtoMessage()               {}
func (*DBEntry) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{4} }

func (m *DBEntry) GetControllerId() string {
	if m != nil {
		return m.ControllerId
	}
	return ""
}

func (m *DBEntry) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type MapVolumeRequest struct {
	// An identifier for the volume that must be unique
	// among all volumes mapped by the OIM controller.
	// All calls with the same identifier must have the
	// same parameters.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// These parameters define how to access the volume.
	//
	// Types that are valid to be assigned to Params:
	//	*MapVolumeRequest_Malloc
	//	*MapVolumeRequest_Ceph
	Params isMapVolumeRequest_Params `protobuf_oneof:"params"`
}

func (m *MapVolumeRequest) Reset()                    { *m = MapVolumeRequest{} }
func (m *MapVolumeRequest) String() string            { return proto.CompactTextString(m) }
func (*MapVolumeRequest) ProtoMessage()               {}
func (*MapVolumeRequest) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{5} }

type isMapVolumeRequest_Params interface {
	isMapVolumeRequest_Params()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MapVolumeRequest_Malloc struct {
	Malloc *MallocParams `protobuf:"bytes,2,opt,name=malloc,oneof"`
}
type MapVolumeRequest_Ceph struct {
	Ceph *CephParams `protobuf:"bytes,3,opt,name=ceph,oneof"`
}

func (*MapVolumeRequest_Malloc) isMapVolumeRequest_Params() {}
func (*MapVolumeRequest_Ceph) isMapVolumeRequest_Params()   {}

func (m *MapVolumeRequest) GetParams() isMapVolumeRequest_Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *MapVolumeRequest) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *MapVolumeRequest) GetMalloc() *MallocParams {
	if x, ok := m.GetParams().(*MapVolumeRequest_Malloc); ok {
		return x.Malloc
	}
	return nil
}

func (m *MapVolumeRequest) GetCeph() *CephParams {
	if x, ok := m.GetParams().(*MapVolumeRequest_Ceph); ok {
		return x.Ceph
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MapVolumeRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MapVolumeRequest_OneofMarshaler, _MapVolumeRequest_OneofUnmarshaler, _MapVolumeRequest_OneofSizer, []interface{}{
		(*MapVolumeRequest_Malloc)(nil),
		(*MapVolumeRequest_Ceph)(nil),
	}
}

func _MapVolumeRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MapVolumeRequest)
	// params
	switch x := m.Params.(type) {
	case *MapVolumeRequest_Malloc:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Malloc); err != nil {
			return err
		}
	case *MapVolumeRequest_Ceph:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ceph); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MapVolumeRequest.Params has unexpected type %T", x)
	}
	return nil
}

func _MapVolumeRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MapVolumeRequest)
	switch tag {
	case 2: // params.malloc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MallocParams)
		err := b.DecodeMessage(msg)
		m.Params = &MapVolumeRequest_Malloc{msg}
		return true, err
	case 3: // params.ceph
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CephParams)
		err := b.DecodeMessage(msg)
		m.Params = &MapVolumeRequest_Ceph{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MapVolumeRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MapVolumeRequest)
	// params
	switch x := m.Params.(type) {
	case *MapVolumeRequest_Malloc:
		s := proto.Size(x.Malloc)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MapVolumeRequest_Ceph:
		s := proto.Size(x.Ceph)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// For testing purposes, an existing Malloc BDev can be used.
// It needs to be provisioned separately to ensure that its
// data survives multiple Map/Unmap operations. It's name
// must be <volume_id>.
type MallocParams struct {
}

func (m *MallocParams) Reset()                    { *m = MallocParams{} }
func (m *MallocParams) String() string            { return proto.CompactTextString(m) }
func (*MallocParams) ProtoMessage()               {}
func (*MallocParams) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{6} }

// Defines a Ceph block device.
type CephParams struct {
	// The user id (like "admin", but not "client.admin").
	// Can be left out, the default in Ceph is "admin".
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// The "key" value from a Ceph keyring for the user.
	Secret string `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
	// Comma-separated list of addr:port values.
	Monitors string `protobuf:"bytes,3,opt,name=monitors,proto3" json:"monitors,omitempty"`
	// Pool name
	Pool string `protobuf:"bytes,4,opt,name=pool,proto3" json:"pool,omitempty"`
	// Image name
	Image string `protobuf:"bytes,5,opt,name=image,proto3" json:"image,omitempty"`
}

func (m *CephParams) Reset()                    { *m = CephParams{} }
func (m *CephParams) String() string            { return proto.CompactTextString(m) }
func (*CephParams) ProtoMessage()               {}
func (*CephParams) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{7} }

func (m *CephParams) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *CephParams) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

func (m *CephParams) GetMonitors() string {
	if m != nil {
		return m.Monitors
	}
	return ""
}

func (m *CephParams) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *CephParams) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

// The reply must tell the caller enough about the mapped volume
// to find it in /sys/dev/block.
type MapVolumeReply struct {
	// The PCI address (domain/bus/device/function, extended BDF).
	// A controller which does not know its own PCI address can
	// return a an address with all fields set to 0xFFFF.
	PciAddress *PCIAddress `protobuf:"bytes,1,opt,name=pci_address,json=pciAddress" json:"pci_address,omitempty"`
	// The SCSI target and LUN. Only present for disks attached
	// via a SCSI controller.
	ScsiDisk *SCSIDisk `protobuf:"bytes,2,opt,name=scsi_disk,json=scsiDisk" json:"scsi_disk,omitempty"`
}

func (m *MapVolumeReply) Reset()                    { *m = MapVolumeReply{} }
func (m *MapVolumeReply) String() string            { return proto.CompactTextString(m) }
func (*MapVolumeReply) ProtoMessage()               {}
func (*MapVolumeReply) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{8} }

func (m *MapVolumeReply) GetPciAddress() *PCIAddress {
	if m != nil {
		return m.PciAddress
	}
	return nil
}

func (m *MapVolumeReply) GetScsiDisk() *SCSIDisk {
	if m != nil {
		return m.ScsiDisk
	}
	return nil
}

// Each field can be marked as unknown or unset with 0xFFFF.
// This leads to nicer code than the other workarounds for missing
// optional scalars (.google.protobuf.UInt32Value or oneof).
type PCIAddress struct {
	// Domain number.
	Domain uint32 `protobuf:"varint,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// Bus number.
	Bus uint32 `protobuf:"varint,2,opt,name=bus,proto3" json:"bus,omitempty"`
	// Device number.
	Device uint32 `protobuf:"varint,3,opt,name=device,proto3" json:"device,omitempty"`
	// Function number.
	Function uint32 `protobuf:"varint,4,opt,name=function,proto3" json:"function,omitempty"`
}

func (m *PCIAddress) Reset()                    { *m = PCIAddress{} }
func (m *PCIAddress) String() string            { return proto.CompactTextString(m) }
func (*PCIAddress) ProtoMessage()               {}
func (*PCIAddress) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{9} }

func (m *PCIAddress) GetDomain() uint32 {
	if m != nil {
		return m.Domain
	}
	return 0
}

func (m *PCIAddress) GetBus() uint32 {
	if m != nil {
		return m.Bus
	}
	return 0
}

func (m *PCIAddress) GetDevice() uint32 {
	if m != nil {
		return m.Device
	}
	return 0
}

func (m *PCIAddress) GetFunction() uint32 {
	if m != nil {
		return m.Function
	}
	return 0
}

type SCSIDisk struct {
	Target uint32 `protobuf:"varint,1,opt,name=target,proto3" json:"target,omitempty"`
	Lun    uint32 `protobuf:"varint,2,opt,name=lun,proto3" json:"lun,omitempty"`
}

func (m *SCSIDisk) Reset()                    { *m = SCSIDisk{} }
func (m *SCSIDisk) String() string            { return proto.CompactTextString(m) }
func (*SCSIDisk) ProtoMessage()               {}
func (*SCSIDisk) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{10} }

func (m *SCSIDisk) GetTarget() uint32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *SCSIDisk) GetLun() uint32 {
	if m != nil {
		return m.Lun
	}
	return 0
}

type UnmapVolumeRequest struct {
	// The volume ID that was used when mapping the volume.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
}

func (m *UnmapVolumeRequest) Reset()                    { *m = UnmapVolumeRequest{} }
func (m *UnmapVolumeRequest) String() string            { return proto.CompactTextString(m) }
func (*UnmapVolumeRequest) ProtoMessage()               {}
func (*UnmapVolumeRequest) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{11} }

func (m *UnmapVolumeRequest) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

type UnmapVolumeReply struct {
}

func (m *UnmapVolumeReply) Reset()                    { *m = UnmapVolumeReply{} }
func (m *UnmapVolumeReply) String() string            { return proto.CompactTextString(m) }
func (*UnmapVolumeReply) ProtoMessage()               {}
func (*UnmapVolumeReply) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{12} }

type ProvisionMallocBDevRequest struct {
	// The desired name of the new BDev.
	BdevName string `protobuf:"bytes,1,opt,name=bdev_name,json=bdevName,proto3" json:"bdev_name,omitempty"`
	// The desired size in bytes. Must be a multiple of 512.
	Size_ int64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *ProvisionMallocBDevRequest) Reset()                    { *m = ProvisionMallocBDevRequest{} }
func (m *ProvisionMallocBDevRequest) String() string            { return proto.CompactTextString(m) }
func (*ProvisionMallocBDevRequest) ProtoMessage()               {}
func (*ProvisionMallocBDevRequest) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{13} }

func (m *ProvisionMallocBDevRequest) GetBdevName() string {
	if m != nil {
		return m.BdevName
	}
	return ""
}

func (m *ProvisionMallocBDevRequest) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type ProvisionMallocBDevReply struct {
}

func (m *ProvisionMallocBDevReply) Reset()                    { *m = ProvisionMallocBDevReply{} }
func (m *ProvisionMallocBDevReply) String() string            { return proto.CompactTextString(m) }
func (*ProvisionMallocBDevReply) ProtoMessage()               {}
func (*ProvisionMallocBDevReply) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{14} }

type CheckMallocBDevRequest struct {
	// The name of an existing BDev.
	BdevName string `protobuf:"bytes,1,opt,name=bdev_name,json=bdevName,proto3" json:"bdev_name,omitempty"`
}

func (m *CheckMallocBDevRequest) Reset()                    { *m = CheckMallocBDevRequest{} }
func (m *CheckMallocBDevRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckMallocBDevRequest) ProtoMessage()               {}
func (*CheckMallocBDevRequest) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{15} }

func (m *CheckMallocBDevRequest) GetBdevName() string {
	if m != nil {
		return m.BdevName
	}
	return ""
}

type CheckMallocBDevReply struct {
}

func (m *CheckMallocBDevReply) Reset()                    { *m = CheckMallocBDevReply{} }
func (m *CheckMallocBDevReply) String() string            { return proto.CompactTextString(m) }
func (*CheckMallocBDevReply) ProtoMessage()               {}
func (*CheckMallocBDevReply) Descriptor() ([]byte, []int) { return fileDescriptorOim, []int{16} }

func init() {
	proto.RegisterType((*RegisterControllerRequest)(nil), "oim.v0.RegisterControllerRequest")
	proto.RegisterType((*RegisterControllerReply)(nil), "oim.v0.RegisterControllerReply")
	proto.RegisterType((*GetControllerRequest)(nil), "oim.v0.GetControllerRequest")
	proto.RegisterType((*GetControllerReply)(nil), "oim.v0.GetControllerReply")
	proto.RegisterType((*DBEntry)(nil), "oim.v0.DBEntry")
	proto.RegisterType((*MapVolumeRequest)(nil), "oim.v0.MapVolumeRequest")
	proto.RegisterType((*MallocParams)(nil), "oim.v0.MallocParams")
	proto.RegisterType((*CephParams)(nil), "oim.v0.CephParams")
	proto.RegisterType((*MapVolumeReply)(nil), "oim.v0.MapVolumeReply")
	proto.RegisterType((*PCIAddress)(nil), "oim.v0.PCIAddress")
	proto.RegisterType((*SCSIDisk)(nil), "oim.v0.SCSIDisk")
	proto.RegisterType((*UnmapVolumeRequest)(nil), "oim.v0.UnmapVolumeRequest")
	proto.RegisterType((*UnmapVolumeReply)(nil), "oim.v0.UnmapVolumeReply")
	proto.RegisterType((*ProvisionMallocBDevRequest)(nil), "oim.v0.ProvisionMallocBDevRequest")
	proto.RegisterType((*ProvisionMallocBDevReply)(nil), "oim.v0.ProvisionMallocBDevReply")
	proto.RegisterType((*CheckMallocBDevRequest)(nil), "oim.v0.CheckMallocBDevRequest")
	proto.RegisterType((*CheckMallocBDevReply)(nil), "oim.v0.CheckMallocBDevReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Registry service

type RegistryClient interface {
	// Adds a new entry to the registry DB or overwrites
	// an existing one.
	RegisterController(ctx context.Context, in *RegisterControllerRequest, opts ...grpc.CallOption) (*RegisterControllerReply, error)
	// Retrieves all registry DB entries.
	GetControllers(ctx context.Context, in *GetControllerRequest, opts ...grpc.CallOption) (*GetControllerReply, error)
}

type registryClient struct {
	cc *grpc.ClientConn
}

func NewRegistryClient(cc *grpc.ClientConn) RegistryClient {
	return &registryClient{cc}
}

func (c *registryClient) RegisterController(ctx context.Context, in *RegisterControllerRequest, opts ...grpc.CallOption) (*RegisterControllerReply, error) {
	out := new(RegisterControllerReply)
	err := grpc.Invoke(ctx, "/oim.v0.Registry/RegisterController", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) GetControllers(ctx context.Context, in *GetControllerRequest, opts ...grpc.CallOption) (*GetControllerReply, error) {
	out := new(GetControllerReply)
	err := grpc.Invoke(ctx, "/oim.v0.Registry/GetControllers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Registry service

type RegistryServer interface {
	// Adds a new entry to the registry DB or overwrites
	// an existing one.
	RegisterController(context.Context, *RegisterControllerRequest) (*RegisterControllerReply, error)
	// Retrieves all registry DB entries.
	GetControllers(context.Context, *GetControllerRequest) (*GetControllerReply, error)
}

func RegisterRegistryServer(s *grpc.Server, srv RegistryServer) {
	s.RegisterService(&_Registry_serviceDesc, srv)
}

func _Registry_RegisterController_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterControllerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).RegisterController(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oim.v0.Registry/RegisterController",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).RegisterController(ctx, req.(*RegisterControllerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_GetControllers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetControllerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).GetControllers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oim.v0.Registry/GetControllers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).GetControllers(ctx, req.(*GetControllerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Registry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "oim.v0.Registry",
	HandlerType: (*RegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterController",
			Handler:    _Registry_RegisterController_Handler,
		},
		{
			MethodName: "GetControllers",
			Handler:    _Registry_GetControllers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "oim.proto",
}

// Client API for Controller service

type ControllerClient interface {
	// Makes a volume available via the accelerator hardware.
	// The call must be idempotent: when a caller is unsure whether
	// a call was executed or what the result was, MapVolume
	// can be called again and will succeed without changing
	// anything.
	MapVolume(ctx context.Context, in *MapVolumeRequest, opts ...grpc.CallOption) (*MapVolumeReply, error)
	// Removes access to the volume.
	// Also idempotent.
	UnmapVolume(ctx context.Context, in *UnmapVolumeRequest, opts ...grpc.CallOption) (*UnmapVolumeReply, error)
	// Creates or deletes (when size is zero) an
	// in-memory BDev for testing.
	ProvisionMallocBDev(ctx context.Context, in *ProvisionMallocBDevRequest, opts ...grpc.CallOption) (*ProvisionMallocBDevReply, error)
	// Checks that the BDev exists. Returns
	// gRPC NOT_FOUND status if not.
	CheckMallocBDev(ctx context.Context, in *CheckMallocBDevRequest, opts ...grpc.CallOption) (*CheckMallocBDevReply, error)
}

type controllerClient struct {
	cc *grpc.ClientConn
}

func NewControllerClient(cc *grpc.ClientConn) ControllerClient {
	return &controllerClient{cc}
}

func (c *controllerClient) MapVolume(ctx context.Context, in *MapVolumeRequest, opts ...grpc.CallOption) (*MapVolumeReply, error) {
	out := new(MapVolumeReply)
	err := grpc.Invoke(ctx, "/oim.v0.Controller/MapVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) UnmapVolume(ctx context.Context, in *UnmapVolumeRequest, opts ...grpc.CallOption) (*UnmapVolumeReply, error) {
	out := new(UnmapVolumeReply)
	err := grpc.Invoke(ctx, "/oim.v0.Controller/UnmapVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) ProvisionMallocBDev(ctx context.Context, in *ProvisionMallocBDevRequest, opts ...grpc.CallOption) (*ProvisionMallocBDevReply, error) {
	out := new(ProvisionMallocBDevReply)
	err := grpc.Invoke(ctx, "/oim.v0.Controller/ProvisionMallocBDev", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) CheckMallocBDev(ctx context.Context, in *CheckMallocBDevRequest, opts ...grpc.CallOption) (*CheckMallocBDevReply, error) {
	out := new(CheckMallocBDevReply)
	err := grpc.Invoke(ctx, "/oim.v0.Controller/CheckMallocBDev", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Controller service

type ControllerServer interface {
	// Makes a volume available via the accelerator hardware.
	// The call must be idempotent: when a caller is unsure whether
	// a call was executed or what the result was, MapVolume
	// can be called again and will succeed without changing
	// anything.
	MapVolume(context.Context, *MapVolumeRequest) (*MapVolumeReply, error)
	// Removes access to the volume.
	// Also idempotent.
	UnmapVolume(context.Context, *UnmapVolumeRequest) (*UnmapVolumeReply, error)
	// Creates or deletes (when size is zero) an
	// in-memory BDev for testing.
	ProvisionMallocBDev(context.Context, *ProvisionMallocBDevRequest) (*ProvisionMallocBDevReply, error)
	// Checks that the BDev exists. Returns
	// gRPC NOT_FOUND status if not.
	CheckMallocBDev(context.Context, *CheckMallocBDevRequest) (*CheckMallocBDevReply, error)
}

func RegisterControllerServer(s *grpc.Server, srv ControllerServer) {
	s.RegisterService(&_Controller_serviceDesc, srv)
}

func _Controller_MapVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MapVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).MapVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oim.v0.Controller/MapVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).MapVolume(ctx, req.(*MapVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_UnmapVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnmapVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).UnmapVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oim.v0.Controller/UnmapVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).UnmapVolume(ctx, req.(*UnmapVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_ProvisionMallocBDev_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProvisionMallocBDevRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).ProvisionMallocBDev(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oim.v0.Controller/ProvisionMallocBDev",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).ProvisionMallocBDev(ctx, req.(*ProvisionMallocBDevRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_CheckMallocBDev_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckMallocBDevRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).CheckMallocBDev(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oim.v0.Controller/CheckMallocBDev",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).CheckMallocBDev(ctx, req.(*CheckMallocBDevRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Controller_serviceDesc = grpc.ServiceDesc{
	ServiceName: "oim.v0.Controller",
	HandlerType: (*ControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MapVolume",
			Handler:    _Controller_MapVolume_Handler,
		},
		{
			MethodName: "UnmapVolume",
			Handler:    _Controller_UnmapVolume_Handler,
		},
		{
			MethodName: "ProvisionMallocBDev",
			Handler:    _Controller_ProvisionMallocBDev_Handler,
		},
		{
			MethodName: "CheckMallocBDev",
			Handler:    _Controller_CheckMallocBDev_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "oim.proto",
}

func (m *RegisterControllerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterControllerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ControllerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.ControllerId)))
		i += copy(dAtA[i:], m.ControllerId)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *RegisterControllerReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterControllerReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetControllerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetControllerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetControllerReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetControllerReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOim(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DBEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ControllerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.ControllerId)))
		i += copy(dAtA[i:], m.ControllerId)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *MapVolumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapVolumeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VolumeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.VolumeId)))
		i += copy(dAtA[i:], m.VolumeId)
	}
	if m.Params != nil {
		nn1, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *MapVolumeRequest_Malloc) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Malloc != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOim(dAtA, i, uint64(m.Malloc.Size()))
		n2, err := m.Malloc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *MapVolumeRequest_Ceph) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ceph != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOim(dAtA, i, uint64(m.Ceph.Size()))
		n3, err := m.Ceph.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *MallocParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MallocParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CephParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CephParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.UserId)))
		i += copy(dAtA[i:], m.UserId)
	}
	if len(m.Secret) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	if len(m.Monitors) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.Monitors)))
		i += copy(dAtA[i:], m.Monitors)
	}
	if len(m.Pool) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.Pool)))
		i += copy(dAtA[i:], m.Pool)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	return i, nil
}

func (m *MapVolumeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapVolumeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PciAddress != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOim(dAtA, i, uint64(m.PciAddress.Size()))
		n4, err := m.PciAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ScsiDisk != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOim(dAtA, i, uint64(m.ScsiDisk.Size()))
		n5, err := m.ScsiDisk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *PCIAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PCIAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Domain != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOim(dAtA, i, uint64(m.Domain))
	}
	if m.Bus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOim(dAtA, i, uint64(m.Bus))
	}
	if m.Device != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOim(dAtA, i, uint64(m.Device))
	}
	if m.Function != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOim(dAtA, i, uint64(m.Function))
	}
	return i, nil
}

func (m *SCSIDisk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCSIDisk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOim(dAtA, i, uint64(m.Target))
	}
	if m.Lun != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOim(dAtA, i, uint64(m.Lun))
	}
	return i, nil
}

func (m *UnmapVolumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnmapVolumeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VolumeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.VolumeId)))
		i += copy(dAtA[i:], m.VolumeId)
	}
	return i, nil
}

func (m *UnmapVolumeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnmapVolumeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ProvisionMallocBDevRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionMallocBDevRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BdevName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.BdevName)))
		i += copy(dAtA[i:], m.BdevName)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOim(dAtA, i, uint64(m.Size_))
	}
	return i, nil
}

func (m *ProvisionMallocBDevReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionMallocBDevReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CheckMallocBDevRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckMallocBDevRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BdevName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOim(dAtA, i, uint64(len(m.BdevName)))
		i += copy(dAtA[i:], m.BdevName)
	}
	return i, nil
}

func (m *CheckMallocBDevReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckMallocBDevReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintOim(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RegisterControllerRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ControllerId)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	return n
}

func (m *RegisterControllerReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetControllerRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetControllerReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovOim(uint64(l))
		}
	}
	return n
}

func (m *DBEntry) Size() (n int) {
	var l int
	_ = l
	l = len(m.ControllerId)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	return n
}

func (m *MapVolumeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.VolumeId)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	if m.Params != nil {
		n += m.Params.Size()
	}
	return n
}

func (m *MapVolumeRequest_Malloc) Size() (n int) {
	var l int
	_ = l
	if m.Malloc != nil {
		l = m.Malloc.Size()
		n += 1 + l + sovOim(uint64(l))
	}
	return n
}
func (m *MapVolumeRequest_Ceph) Size() (n int) {
	var l int
	_ = l
	if m.Ceph != nil {
		l = m.Ceph.Size()
		n += 1 + l + sovOim(uint64(l))
	}
	return n
}
func (m *MallocParams) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CephParams) Size() (n int) {
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	l = len(m.Monitors)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	l = len(m.Pool)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	return n
}

func (m *MapVolumeReply) Size() (n int) {
	var l int
	_ = l
	if m.PciAddress != nil {
		l = m.PciAddress.Size()
		n += 1 + l + sovOim(uint64(l))
	}
	if m.ScsiDisk != nil {
		l = m.ScsiDisk.Size()
		n += 1 + l + sovOim(uint64(l))
	}
	return n
}

func (m *PCIAddress) Size() (n int) {
	var l int
	_ = l
	if m.Domain != 0 {
		n += 1 + sovOim(uint64(m.Domain))
	}
	if m.Bus != 0 {
		n += 1 + sovOim(uint64(m.Bus))
	}
	if m.Device != 0 {
		n += 1 + sovOim(uint64(m.Device))
	}
	if m.Function != 0 {
		n += 1 + sovOim(uint64(m.Function))
	}
	return n
}

func (m *SCSIDisk) Size() (n int) {
	var l int
	_ = l
	if m.Target != 0 {
		n += 1 + sovOim(uint64(m.Target))
	}
	if m.Lun != 0 {
		n += 1 + sovOim(uint64(m.Lun))
	}
	return n
}

func (m *UnmapVolumeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.VolumeId)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	return n
}

func (m *UnmapVolumeReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ProvisionMallocBDevRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.BdevName)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovOim(uint64(m.Size_))
	}
	return n
}

func (m *ProvisionMallocBDevReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CheckMallocBDevRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.BdevName)
	if l > 0 {
		n += 1 + l + sovOim(uint64(l))
	}
	return n
}

func (m *CheckMallocBDevReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovOim(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOim(x uint64) (n int) {
	return sovOim(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RegisterControllerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterControllerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterControllerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControllerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterControllerReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterControllerReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterControllerReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetControllerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetControllerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetControllerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetControllerReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetControllerReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetControllerReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &DBEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DBEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControllerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapVolumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapVolumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapVolumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Malloc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MallocParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Params = &MapVolumeRequest_Malloc{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ceph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CephParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Params = &MapVolumeRequest_Ceph{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MallocParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MallocParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MallocParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CephParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CephParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CephParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Monitors = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapVolumeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapVolumeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapVolumeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PciAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PciAddress == nil {
				m.PciAddress = &PCIAddress{}
			}
			if err := m.PciAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScsiDisk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScsiDisk == nil {
				m.ScsiDisk = &SCSIDisk{}
			}
			if err := m.ScsiDisk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PCIAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PCIAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PCIAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bus", wireType)
			}
			m.Bus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			m.Device = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Device |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			m.Function = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Function |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCSIDisk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCSIDisk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCSIDisk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lun", wireType)
			}
			m.Lun = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lun |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnmapVolumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnmapVolumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnmapVolumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnmapVolumeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnmapVolumeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnmapVolumeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionMallocBDevRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionMallocBDevRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionMallocBDevRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BdevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BdevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionMallocBDevReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionMallocBDevReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionMallocBDevReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckMallocBDevRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckMallocBDevRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckMallocBDevRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BdevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOim
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BdevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckMallocBDevReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckMallocBDevReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckMallocBDevReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOim(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOim
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOim
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOim
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOim
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOim
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOim(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOim = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOim   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("oim.proto", fileDescriptorOim) }

var fileDescriptorOim = []byte{
	// 728 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xdd, 0x4e, 0xdb, 0x4a,
	0x10, 0xc6, 0x04, 0xf2, 0x33, 0x21, 0x10, 0xed, 0xe1, 0x04, 0xe3, 0x83, 0x72, 0x38, 0x7b, 0x6e,
	0xe8, 0x45, 0x43, 0x1b, 0xda, 0x6b, 0xd4, 0x04, 0x54, 0x22, 0x95, 0x8a, 0x1a, 0xb5, 0x17, 0x48,
	0x55, 0xe4, 0xd8, 0x4b, 0xd8, 0x62, 0x7b, 0xdd, 0x5d, 0x3b, 0x55, 0x7a, 0xdb, 0x17, 0xa8, 0xd4,
	0x57, 0xe9, 0x33, 0x54, 0xbd, 0xec, 0x23, 0x54, 0xf4, 0x45, 0xaa, 0x5d, 0xff, 0x24, 0x21, 0x0e,
	0x12, 0xea, 0xdd, 0xce, 0x37, 0xdf, 0x7c, 0x33, 0xb3, 0xb3, 0x1e, 0x43, 0x85, 0x51, 0xaf, 0x15,
	0x70, 0x16, 0x32, 0x54, 0x94, 0xc7, 0xd1, 0x23, 0xa3, 0x39, 0x64, 0x6c, 0xe8, 0x92, 0x7d, 0x85,
	0x0e, 0xa2, 0xcb, 0xfd, 0x0f, 0xdc, 0x0a, 0x02, 0xc2, 0x45, 0xcc, 0xc3, 0x17, 0xb0, 0x6d, 0x92,
	0x21, 0x15, 0x21, 0xe1, 0x5d, 0xe6, 0x87, 0x9c, 0xb9, 0x2e, 0xe1, 0x26, 0x79, 0x1f, 0x11, 0x11,
	0xa2, 0xff, 0xa1, 0x66, 0x67, 0x60, 0x9f, 0x3a, 0xba, 0xb6, 0xab, 0xed, 0x55, 0xcc, 0xb5, 0x09,
	0xd8, 0x73, 0x90, 0x0e, 0x25, 0xcb, 0x71, 0x38, 0x11, 0x42, 0x5f, 0x56, 0xee, 0xd4, 0xc4, 0xdb,
	0xb0, 0x95, 0xa7, 0x1d, 0xb8, 0x63, 0xdc, 0x80, 0xcd, 0xe7, 0x24, 0x9c, 0xcb, 0x88, 0x0f, 0x01,
	0xdd, 0xc2, 0x03, 0x77, 0x8c, 0x1e, 0x40, 0x89, 0xf8, 0x21, 0xa7, 0x44, 0xe8, 0xda, 0x6e, 0x61,
	0xaf, 0xda, 0xde, 0x68, 0xc5, 0xed, 0xb5, 0x8e, 0x3a, 0xc7, 0x7e, 0xc8, 0xc7, 0x66, 0xea, 0xc7,
	0x27, 0x50, 0x4a, 0xb0, 0x3f, 0xad, 0xfe, 0x8b, 0x06, 0xf5, 0x53, 0x2b, 0x78, 0xc3, 0xdc, 0xc8,
	0x23, 0xe9, 0x8d, 0xfc, 0x03, 0x95, 0x91, 0x02, 0x26, 0x7a, 0xe5, 0x18, 0xe8, 0x39, 0xa8, 0x05,
	0x45, 0xcf, 0x72, 0x5d, 0x66, 0x2b, 0xa9, 0x6a, 0x7b, 0x33, 0xad, 0xf2, 0x54, 0xa1, 0x67, 0x16,
	0xb7, 0x3c, 0x71, 0xb2, 0x64, 0x26, 0x2c, 0xb4, 0x07, 0x2b, 0x36, 0x09, 0xae, 0xf4, 0x82, 0x62,
	0xa3, 0x94, 0xdd, 0x25, 0xc1, 0x55, 0xc6, 0x55, 0x8c, 0x4e, 0x19, 0x8a, 0x81, 0x42, 0xf0, 0x3a,
	0xac, 0x4d, 0xab, 0xe1, 0x4f, 0x1a, 0xc0, 0x24, 0x00, 0x6d, 0x41, 0x29, 0x12, 0xd3, 0xdd, 0x16,
	0xa5, 0xd9, 0x73, 0x50, 0x03, 0x8a, 0x82, 0xd8, 0x9c, 0x84, 0x49, 0x9b, 0x89, 0x85, 0x0c, 0x28,
	0x7b, 0xcc, 0xa7, 0x21, 0xe3, 0x42, 0xd5, 0x51, 0x31, 0x33, 0x1b, 0x21, 0x58, 0x09, 0x18, 0x73,
	0xf5, 0x15, 0x85, 0xab, 0x33, 0xda, 0x84, 0x55, 0xea, 0x59, 0x43, 0xa2, 0xaf, 0x2a, 0x30, 0x36,
	0x70, 0x08, 0xeb, 0x53, 0x57, 0x25, 0x47, 0x76, 0x00, 0xd5, 0xc0, 0xa6, 0xfd, 0xf4, 0x6e, 0xb5,
	0xd9, 0x16, 0xcf, 0xba, 0xbd, 0x67, 0xb1, 0xc7, 0x84, 0xc0, 0xa6, 0xc9, 0x19, 0x3d, 0x84, 0x8a,
	0xb0, 0x05, 0xed, 0x3b, 0x54, 0x5c, 0x27, 0x77, 0x58, 0x4f, 0x43, 0xce, 0xbb, 0xe7, 0xbd, 0x23,
	0x2a, 0xae, 0xcd, 0xb2, 0xa4, 0xc8, 0x13, 0x7e, 0x07, 0x30, 0x11, 0x92, 0x1d, 0x3a, 0xcc, 0xb3,
	0xa8, 0xaf, 0x92, 0xd5, 0xcc, 0xc4, 0x42, 0x75, 0x28, 0x0c, 0xa2, 0x78, 0xba, 0x35, 0x53, 0x1e,
	0x15, 0x93, 0x8c, 0xa8, 0x4d, 0x54, 0xc7, 0x92, 0xa9, 0x2c, 0x79, 0x17, 0x97, 0x91, 0x6f, 0x87,
	0x94, 0xf9, 0xaa, 0xe7, 0x9a, 0x99, 0xd9, 0xf8, 0x09, 0x94, 0xd3, 0x0a, 0x64, 0x7c, 0x68, 0xf1,
	0x21, 0x09, 0xd3, 0x4c, 0xb1, 0x25, 0x33, 0xb9, 0x91, 0x9f, 0x66, 0x72, 0x23, 0x1f, 0x3f, 0x06,
	0xf4, 0xda, 0xf7, 0xee, 0xf3, 0x88, 0x30, 0x82, 0xfa, 0x4c, 0x88, 0xfc, 0x5a, 0x4e, 0xc1, 0x38,
	0xe3, 0x6c, 0x44, 0x05, 0x65, 0x7e, 0x3c, 0xfd, 0xce, 0x11, 0x19, 0x4d, 0xc9, 0x0d, 0x1c, 0x32,
	0xea, 0xfb, 0x96, 0x47, 0x52, 0x39, 0x09, 0xbc, 0xb4, 0x3c, 0x22, 0x67, 0x28, 0xe8, 0x47, 0xa2,
	0x8a, 0x2a, 0x98, 0xea, 0x8c, 0x0d, 0xd0, 0x73, 0xe5, 0x64, 0xaa, 0xa7, 0xd0, 0xe8, 0x5e, 0x11,
	0xfb, 0xfa, 0x7e, 0x69, 0xe4, 0xf7, 0x3c, 0x17, 0x16, 0xb8, 0xe3, 0xf6, 0x57, 0x0d, 0xca, 0xf1,
	0x0e, 0xe0, 0x63, 0x74, 0x01, 0x68, 0x7e, 0x1f, 0xa0, 0xff, 0xd2, 0x09, 0x2f, 0xdc, 0x43, 0xc6,
	0xbf, 0x77, 0x51, 0x64, 0xd5, 0x4b, 0xe8, 0x05, 0xac, 0xcf, 0x2c, 0x0e, 0x81, 0x76, 0xd2, 0xa0,
	0xbc, 0x45, 0x63, 0x18, 0x0b, 0xbc, 0x4a, 0xad, 0xfd, 0x6d, 0x19, 0x60, 0xaa, 0xc4, 0x43, 0xa8,
	0x64, 0xcf, 0x1b, 0xe9, 0x93, 0xaf, 0x7a, 0x76, 0xae, 0x46, 0x23, 0xc7, 0x13, 0x57, 0x77, 0x0c,
	0xd5, 0xa9, 0xa1, 0xa2, 0x2c, 0xf9, 0xfc, 0xe3, 0x30, 0xf4, 0x5c, 0x5f, 0x2c, 0xf3, 0x16, 0xfe,
	0xca, 0x19, 0x1c, 0xc2, 0xd9, 0x67, 0xb5, 0xf0, 0x91, 0x18, 0xbb, 0x77, 0x72, 0x62, 0xf9, 0x57,
	0xb0, 0x71, 0x6b, 0x88, 0xa8, 0x99, 0x2d, 0xa5, 0xdc, 0x47, 0x61, 0xec, 0x2c, 0xf4, 0x2b, 0xc9,
	0xce, 0xdf, 0xdf, 0x6f, 0x9a, 0xda, 0x8f, 0x9b, 0xa6, 0xf6, 0xf3, 0xa6, 0xa9, 0x7d, 0xfe, 0xd5,
	0x5c, 0xba, 0x28, 0x30, 0xea, 0x0d, 0x8a, 0xea, 0xe7, 0x73, 0xf0, 0x3b, 0x00, 0x00, 0xff, 0xff,
	0x2e, 0x00, 0xdc, 0x1d, 0xb1, 0x06, 0x00, 0x00,
}
