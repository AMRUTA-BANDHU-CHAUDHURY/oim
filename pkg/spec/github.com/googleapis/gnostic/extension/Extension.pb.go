// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: extension.proto

/*
	Package openapiextension_v1 is a generated protocol buffer package.

	It is generated from these files:
		extension.proto

	It has these top-level messages:
		Version
		ExtensionHandlerRequest
		ExtensionHandlerResponse
		Wrapper
*/
package openapiextension_v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// The version number of OpenAPI compiler.
type Version struct {
	Major int32 `protobuf:"varint,1,opt,name=major,proto3" json:"major,omitempty"`
	Minor int32 `protobuf:"varint,2,opt,name=minor,proto3" json:"minor,omitempty"`
	Patch int32 `protobuf:"varint,3,opt,name=patch,proto3" json:"patch,omitempty"`
	// A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
	// be empty for mainline stable releases.
	Suffix string `protobuf:"bytes,4,opt,name=suffix,proto3" json:"suffix,omitempty"`
}

func (m *Version) Reset()                    { *m = Version{} }
func (m *Version) String() string            { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()               {}
func (*Version) Descriptor() ([]byte, []int) { return fileDescriptorExtension, []int{0} }

func (m *Version) GetMajor() int32 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *Version) GetMinor() int32 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *Version) GetPatch() int32 {
	if m != nil {
		return m.Patch
	}
	return 0
}

func (m *Version) GetSuffix() string {
	if m != nil {
		return m.Suffix
	}
	return ""
}

// An encoded Request is written to the ExtensionHandler's stdin.
type ExtensionHandlerRequest struct {
	// The OpenAPI descriptions that were explicitly listed on the command line.
	// The specifications will appear in the order they are specified to gnostic.
	Wrapper *Wrapper `protobuf:"bytes,1,opt,name=wrapper" json:"wrapper,omitempty"`
	// The version number of openapi compiler.
	CompilerVersion *Version `protobuf:"bytes,3,opt,name=compiler_version,json=compilerVersion" json:"compiler_version,omitempty"`
}

func (m *ExtensionHandlerRequest) Reset()                    { *m = ExtensionHandlerRequest{} }
func (m *ExtensionHandlerRequest) String() string            { return proto.CompactTextString(m) }
func (*ExtensionHandlerRequest) ProtoMessage()               {}
func (*ExtensionHandlerRequest) Descriptor() ([]byte, []int) { return fileDescriptorExtension, []int{1} }

func (m *ExtensionHandlerRequest) GetWrapper() *Wrapper {
	if m != nil {
		return m.Wrapper
	}
	return nil
}

func (m *ExtensionHandlerRequest) GetCompilerVersion() *Version {
	if m != nil {
		return m.CompilerVersion
	}
	return nil
}

// The extensions writes an encoded ExtensionHandlerResponse to stdout.
type ExtensionHandlerResponse struct {
	// true if the extension is handled by the extension handler; false otherwise
	Handled bool `protobuf:"varint,1,opt,name=handled,proto3" json:"handled,omitempty"`
	// Error message.  If non-empty, the extension handling failed.
	// The extension handler process should exit with status code zero
	// even if it reports an error in this way.
	//
	// This should be used to indicate errors which prevent the extension from
	// operating as intended.  Errors which indicate a problem in gnostic
	// itself -- such as the input Document being unparseable -- should be
	// reported by writing a message to stderr and exiting with a non-zero
	// status code.
	Error []string `protobuf:"bytes,2,rep,name=error" json:"error,omitempty"`
	// text output
	Value *google_protobuf.Any `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *ExtensionHandlerResponse) Reset()         { *m = ExtensionHandlerResponse{} }
func (m *ExtensionHandlerResponse) String() string { return proto.CompactTextString(m) }
func (*ExtensionHandlerResponse) ProtoMessage()    {}
func (*ExtensionHandlerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorExtension, []int{2}
}

func (m *ExtensionHandlerResponse) GetHandled() bool {
	if m != nil {
		return m.Handled
	}
	return false
}

func (m *ExtensionHandlerResponse) GetError() []string {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExtensionHandlerResponse) GetValue() *google_protobuf.Any {
	if m != nil {
		return m.Value
	}
	return nil
}

type Wrapper struct {
	// version of the OpenAPI specification in which this extension was written.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Name of the extension
	ExtensionName string `protobuf:"bytes,2,opt,name=extension_name,json=extensionName,proto3" json:"extension_name,omitempty"`
	// Must be a valid yaml for the proto
	Yaml string `protobuf:"bytes,3,opt,name=yaml,proto3" json:"yaml,omitempty"`
}

func (m *Wrapper) Reset()                    { *m = Wrapper{} }
func (m *Wrapper) String() string            { return proto.CompactTextString(m) }
func (*Wrapper) ProtoMessage()               {}
func (*Wrapper) Descriptor() ([]byte, []int) { return fileDescriptorExtension, []int{3} }

func (m *Wrapper) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Wrapper) GetExtensionName() string {
	if m != nil {
		return m.ExtensionName
	}
	return ""
}

func (m *Wrapper) GetYaml() string {
	if m != nil {
		return m.Yaml
	}
	return ""
}

func init() {
	proto.RegisterType((*Version)(nil), "openapiextension.v1.Version")
	proto.RegisterType((*ExtensionHandlerRequest)(nil), "openapiextension.v1.ExtensionHandlerRequest")
	proto.RegisterType((*ExtensionHandlerResponse)(nil), "openapiextension.v1.ExtensionHandlerResponse")
	proto.RegisterType((*Wrapper)(nil), "openapiextension.v1.Wrapper")
}
func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Major != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintExtension(dAtA, i, uint64(m.Major))
	}
	if m.Minor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExtension(dAtA, i, uint64(m.Minor))
	}
	if m.Patch != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExtension(dAtA, i, uint64(m.Patch))
	}
	if len(m.Suffix) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintExtension(dAtA, i, uint64(len(m.Suffix)))
		i += copy(dAtA[i:], m.Suffix)
	}
	return i, nil
}

func (m *ExtensionHandlerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtensionHandlerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Wrapper != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExtension(dAtA, i, uint64(m.Wrapper.Size()))
		n1, err := m.Wrapper.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.CompilerVersion != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExtension(dAtA, i, uint64(m.CompilerVersion.Size()))
		n2, err := m.CompilerVersion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *ExtensionHandlerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtensionHandlerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handled {
		dAtA[i] = 0x8
		i++
		if m.Handled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		for _, s := range m.Error {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Value != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExtension(dAtA, i, uint64(m.Value.Size()))
		n3, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Wrapper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Wrapper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExtension(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.ExtensionName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExtension(dAtA, i, uint64(len(m.ExtensionName)))
		i += copy(dAtA[i:], m.ExtensionName)
	}
	if len(m.Yaml) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExtension(dAtA, i, uint64(len(m.Yaml)))
		i += copy(dAtA[i:], m.Yaml)
	}
	return i, nil
}

func encodeVarintExtension(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Version) Size() (n int) {
	var l int
	_ = l
	if m.Major != 0 {
		n += 1 + sovExtension(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovExtension(uint64(m.Minor))
	}
	if m.Patch != 0 {
		n += 1 + sovExtension(uint64(m.Patch))
	}
	l = len(m.Suffix)
	if l > 0 {
		n += 1 + l + sovExtension(uint64(l))
	}
	return n
}

func (m *ExtensionHandlerRequest) Size() (n int) {
	var l int
	_ = l
	if m.Wrapper != nil {
		l = m.Wrapper.Size()
		n += 1 + l + sovExtension(uint64(l))
	}
	if m.CompilerVersion != nil {
		l = m.CompilerVersion.Size()
		n += 1 + l + sovExtension(uint64(l))
	}
	return n
}

func (m *ExtensionHandlerResponse) Size() (n int) {
	var l int
	_ = l
	if m.Handled {
		n += 2
	}
	if len(m.Error) > 0 {
		for _, s := range m.Error {
			l = len(s)
			n += 1 + l + sovExtension(uint64(l))
		}
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovExtension(uint64(l))
	}
	return n
}

func (m *Wrapper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovExtension(uint64(l))
	}
	l = len(m.ExtensionName)
	if l > 0 {
		n += 1 + l + sovExtension(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovExtension(uint64(l))
	}
	return n
}

func sovExtension(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozExtension(x uint64) (n int) {
	return sovExtension(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtension
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			m.Patch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Patch |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtension
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Suffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExtension(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtension
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtensionHandlerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtension
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtensionHandlerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtensionHandlerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtension
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Wrapper == nil {
				m.Wrapper = &Wrapper{}
			}
			if err := m.Wrapper.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompilerVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtension
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompilerVersion == nil {
				m.CompilerVersion = &Version{}
			}
			if err := m.CompilerVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExtension(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtension
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtensionHandlerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtension
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtensionHandlerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtensionHandlerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Handled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtension
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = append(m.Error, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtension
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &google_protobuf.Any{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExtension(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtension
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Wrapper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtension
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wrapper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wrapper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtension
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtension
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtensionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtension
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExtension(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtension
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExtension(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExtension
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExtension
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthExtension
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowExtension
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExtension(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExtension = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExtension   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("extension.proto", fileDescriptorExtension) }

var fileDescriptorExtension = []byte{
	// 384 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x91, 0xcd, 0xaa, 0xd3, 0x40,
	0x1c, 0xc5, 0x9d, 0x7e, 0xc5, 0x8c, 0xd8, 0xca, 0x58, 0x34, 0x8a, 0x84, 0x12, 0x10, 0x8a, 0x8b,
	0x29, 0x55, 0x70, 0xe5, 0xa6, 0x85, 0xa2, 0x6e, 0x6c, 0x99, 0x45, 0xdd, 0x59, 0xa6, 0xe9, 0xbf,
	0x69, 0x24, 0x99, 0x19, 0x27, 0x1f, 0xb6, 0x6f, 0xe1, 0xda, 0xa5, 0x4f, 0xe3, 0xd2, 0x47, 0x90,
	0xde, 0x17, 0xb9, 0x64, 0x26, 0xe9, 0x5d, 0xdc, 0x7b, 0x77, 0x39, 0x3f, 0x4e, 0xf2, 0x3f, 0xe7,
	0x04, 0x0f, 0xe0, 0x98, 0x83, 0xc8, 0x62, 0x29, 0xa8, 0xd2, 0x32, 0x97, 0xe4, 0xa9, 0x54, 0x20,
	0xb8, 0x8a, 0x6f, 0x78, 0x39, 0x7d, 0xf9, 0x22, 0x92, 0x32, 0x4a, 0x60, 0x62, 0x2c, 0xdb, 0x62,
	0x3f, 0xe1, 0xe2, 0x64, 0xfd, 0x41, 0x88, 0x9d, 0x35, 0xe8, 0xca, 0x48, 0x86, 0xb8, 0x9b, 0xf2,
	0xef, 0x52, 0x7b, 0x68, 0x84, 0xc6, 0x5d, 0x66, 0x85, 0xa1, 0xb1, 0x90, 0xda, 0x6b, 0xd5, 0xb4,
	0x12, 0x15, 0x55, 0x3c, 0x0f, 0x0f, 0x5e, 0xdb, 0x52, 0x23, 0xc8, 0x33, 0xdc, 0xcb, 0x8a, 0xfd,
	0x3e, 0x3e, 0x7a, 0x9d, 0x11, 0x1a, 0xbb, 0xac, 0x56, 0xc1, 0x6f, 0x84, 0x9f, 0x2f, 0x9a, 0x40,
	0x9f, 0xb8, 0xd8, 0x25, 0xa0, 0x19, 0xfc, 0x28, 0x20, 0xcb, 0xc9, 0x7b, 0xec, 0xfc, 0xd4, 0x5c,
	0x29, 0xb0, 0x77, 0x1f, 0xbd, 0x7d, 0x45, 0xef, 0xa8, 0x40, 0xbf, 0x5a, 0x0f, 0x6b, 0xcc, 0xe4,
	0x23, 0x7e, 0x12, 0xca, 0x54, 0xc5, 0x09, 0xe8, 0x4d, 0x69, 0x1b, 0x98, 0x30, 0xf7, 0x7d, 0xa0,
	0x6e, 0xc9, 0x06, 0xcd, 0x5b, 0x35, 0x08, 0x4a, 0xec, 0xdd, 0xce, 0x96, 0x29, 0x29, 0x32, 0x20,
	0x1e, 0x76, 0x0e, 0x06, 0xed, 0x4c, 0xb8, 0x87, 0xac, 0x91, 0xd5, 0x00, 0xa0, 0xb5, 0x99, 0xa5,
	0x3d, 0x76, 0x99, 0x15, 0xe4, 0x0d, 0xee, 0x96, 0x3c, 0x29, 0xa0, 0x4e, 0x32, 0xa4, 0x76, 0x78,
	0xda, 0x0c, 0x4f, 0x67, 0xe2, 0xc4, 0xac, 0x25, 0xf8, 0x86, 0x9d, 0xba, 0x54, 0x75, 0xa6, 0xa9,
	0x80, 0xcc, 0x70, 0x8d, 0x24, 0xaf, 0x71, 0xff, 0xd2, 0x62, 0x23, 0x78, 0x0a, 0xe6, 0x37, 0xb8,
	0xec, 0xf1, 0x85, 0x7e, 0xe1, 0x29, 0x10, 0x82, 0x3b, 0x27, 0x9e, 0x26, 0xe6, 0xac, 0xcb, 0xcc,
	0xf3, 0xfc, 0xc3, 0xdf, 0xb3, 0x8f, 0xfe, 0x9d, 0x7d, 0xf4, 0xff, 0xec, 0xa3, 0x5f, 0x57, 0xfe,
	0x03, 0xdc, 0x97, 0x3a, 0xa2, 0x91, 0x90, 0x59, 0x1e, 0x87, 0xb4, 0x9c, 0xce, 0xc9, 0x52, 0x81,
	0x98, 0xad, 0x3e, 0x5f, 0xea, 0xaf, 0xa7, 0x2b, 0xf4, 0xa7, 0xd5, 0x5e, 0xce, 0x16, 0xdb, 0x9e,
	0x89, 0xfc, 0xee, 0x3a, 0x00, 0x00, 0xff, 0xff, 0x1d, 0xb2, 0x95, 0x05, 0x61, 0x02, 0x00, 0x00,
}
